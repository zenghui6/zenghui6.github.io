<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SSM整合</title>
    <url>/2020/02/22/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h3 id="SSM脚手架"><a href="#SSM脚手架" class="headerlink" title="SSM脚手架"></a>SSM脚手架</h3><p>spring + springMVC + Mybatis + log4j + MybatisGenerator </p>
<p>实现了</p>
<ul>
<li><p>简单配置</p>
</li>
<li><p>日志打印</p>
</li>
<li><p>逆向文件</p>
</li>
<li><p>上传文件的配置</p>
</li>
<li><p>加入了Json 和 Restful 的配置 (在spring-mvc.xml 和 web.xml)</p>
<a id="more"></a>


</li>
</ul>
<h4 id="SSM整合步骤"><a href="#SSM整合步骤" class="headerlink" title="SSM整合步骤"></a>SSM整合步骤</h4><p><img src="https://s2.ax1x.com/2020/02/22/3MQkKe.png" alt="3MQkKe.png"></p>
<h4 id="mybatis-config-xml-简化类命名空间-配置数据源交给spring管理"><a href="#mybatis-config-xml-简化类命名空间-配置数据源交给spring管理" class="headerlink" title="mybatis-config.xml:  简化类命名空间,配置数据源交给spring管理"></a>mybatis-config.xml:  简化类命名空间,配置数据源交给spring管理</h4><h4 id="spring-dao-xml"><a href="#spring-dao-xml" class="headerlink" title="spring-dao.xml :"></a>spring-dao.xml :</h4><ol>
<li><p>关联数据库文件,引入database.properties</p>
</li>
<li><p>配置数据源连接池信息: dataSource</p>
</li>
<li><p>配置sqlSessionFactory对象 :</p>
<ul>
<li>注入数据源 :dataSource</li>
<li>绑定mybatis配置文件 : configLocation</li>
<li>绑定Sql映射文件的地址: mapperLocation</li>
</ul>
</li>
<li><p>配置dao接口扫描包,动态实现dao接口注入到spring容器中</p>
<ul>
<li>将 sqlSessionFactory 注入 bean 中 :  sqlSessionFactoryBeanName</li>
<li>扫描 dao 包<h4 id="spring-service-xml"><a href="#spring-service-xml" class="headerlink" title="spring-service.xml"></a>spring-service.xml</h4></li>
</ul>
</li>
<li><p>开启注解配置  </p>
</li>
<li><p>扫描 service 包</p>
</li>
<li><p>声明事务配置 : DataSourceTransactionManager </p>
</li>
<li><p>aop 事务支持</p>
</li>
</ol>
<h4 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring-mvc.xml:"></a>spring-mvc.xml:</h4><ol>
<li>注解驱动: 可加入对Json传输的支持</li>
<li>静态资源过滤</li>
<li>扫描 Controller 包<ul>
<li>扫描@Controller注解</li>
</ul>
</li>
<li>配置视图解析器</li>
<li>配置文件解析器(可选)</li>
</ol>
<h4 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h4><ol>
<li>配置监听器启动Spring容器</li>
<li>将url控制交给 springMVC 的 DispatcherServlet(核心分发器)</li>
<li>乱码过滤</li>
<li>session过期时间</li>
<li>添加对 put 和 delete方式的支持</li>
</ol>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC工作原理</title>
    <url>/2020/02/17/SpringMVC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="四个组件各司其职"><a href="#四个组件各司其职" class="headerlink" title="四个组件各司其职"></a>四个组件各司其职</h3><ul>
<li>DispatcherServlet: 作为前端控制器,整个流程控制的中心,控制其他组件执行,统一调度,降低组件之间的耦合性,提高每个组件的扩展性</li>
<li>HandlerMapping: 根据配置文件找到具体的处理者(Hander),并生成处理器对象,和处理器拦截器</li>
<li>HandlerAdapter: 将处理者对象(Hander)根据规则(例如get post请求方式) 执行不同的Controller</li>
<li>ViewResolver: 将MAV 解析后 返回具体的 view</li>
</ul>
<a id="more"></a>

<p><img src="https://s2.ax1x.com/2020/02/17/3PRjc6.jpg" alt="3PRjc6.jpg"></p>
<h3 id="SpringMVC工作原理"><a href="#SpringMVC工作原理" class="headerlink" title="SpringMVC工作原理"></a>SpringMVC工作原理</h3><ol>
<li>用户发送请求到<strong>前端控制器</strong> DispatcherServlet</li>
<li>DispatcherServlet收到请求调用 HandlerMapping 处理者映射器</li>
<li>处理者映射器找到具体的处理器(handler) (可以根据xml配置,注解进行查找) , 生成处理器对象和处理器拦截器(如有则生成) 一并返回给DispatcherServlet</li>
<li>DispatcherServlet调用 HanderAdapter 处理者适配器</li>
<li>HanderAdapter 经过适配调用具体的处理器 (Controller)</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HanderAdapter 将Controller返回的ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet 将 ModelAndView 传给 ViewResolver视图解析器</li>
<li>ViewResolver解析后返回具体的view</li>
<li>DispatcherServlet 根据 view进行渲染 (将模型数据填充到视图中)</li>
<li>DispatcherServlet 响应用户</li>
</ol>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射和动态代理</title>
    <url>/2020/02/13/Java%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>Spring IOC 使用的是 Java的反射</p>
<p>Spring AOP 使用的是 动态代理</p>
<a id="more"></a>

<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射?"></a>什么是反射?</h3><p>主要是指程序可以访问,检测和修改它本身状态或行为的一种能力</p>
<p>在Java运行时环境中,对于<strong>任意一个类</strong>,能否知道这个类有哪些属性和方法?对于<strong>任意一个对象</strong> 能否调用它的任意一个方法?</p>
<p>Java的反射机制主要提供了以下功能:</p>
<ol>
<li>在运行时判断任意一个对象所属的类.</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行是调用任意一个对象的方法</li>
</ol>
<h3 id="什么是-Java-的序列化-什么情况下需要序列化"><a href="#什么是-Java-的序列化-什么情况下需要序列化" class="headerlink" title="什么是 Java 的序列化? 什么情况下需要序列化?"></a>什么是 Java 的序列化? 什么情况下需要序列化?</h3><p>Java 序列化是为了保存各种对象在内存中的状态,并且可以把保存的对象再读出来.</p>
<p>以下情况需要使用Java序列化:</p>
<ul>
<li>想把内存中的对象状态保存到一个文件中或数据库中的时候;</li>
<li>想用Socket在网络上传输对象的时候;</li>
<li>想通用远程方法调用传输对象的时候;</li>
</ul>
<p>注意事项:</p>
<ul>
<li>某个类可以被序列化,则其子类也可以被序列化</li>
<li>声明为 static 和 transient 的成员变量,不能被序列化. static 成员变量是描述类级别的属性,transient 表示临时数据</li>
<li>反序列化读取序列化对象的顺序要保持一致</li>
</ul>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><code>Proxy</code> : 代理人——代替别人工作的人 “本人”寻找“代理人”工作，但是代理人毕竟是代理人，能代替本人所做的事有限，当代理人无法帮忙时再寻找本人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IRegisterService iRegisterService = <span class="keyword">new</span> RegisterServiceImpl();</span><br><span class="line">        IRegisterService proxy = <span class="keyword">new</span> RegisterServiceProxy(iRegisterService);</span><br><span class="line">        proxy.register(<span class="string">"RyanLee"</span>, <span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRegisterService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String name, String pwd)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterServiceImpl</span> <span class="keyword">implements</span> <span class="title">IRegisterService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String name, String pwd)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"【向数据库中插入数据】name：%s，pwd：%s"</span>, name, pwd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterServiceProxy</span> <span class="keyword">implements</span> <span class="title">IRegisterService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//本人,代理人持有本人的引用,当代理人无法完成要求时,再生成本人</span></span><br><span class="line">    IRegisterService iRegisterService; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterServiceProxy</span><span class="params">(IRegisterService iRegisterService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iRegisterService = iRegisterService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String name, String pwd)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[Proxy]一些前置处理"</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"[Proxy]打印注册信息：姓名：%s,密码：%s"</span>, name, pwd));</span><br><span class="line">        iRegisterService.register(name, pwd);</span><br><span class="line">        System.out.println(<span class="string">"[Proxy]一些后置处理"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Proxy</span>]一些前置处理</span><br><span class="line">[<span class="meta">Proxy</span>]打印注册信息：姓名：RyanLee,密码：<span class="number">123</span></span><br><span class="line">【向数据库中插入数据】name：RyanLee，pwd：<span class="number">123</span></span><br><span class="line">[<span class="meta">Proxy</span>]一些后置处理</span><br></pre></td></tr></table></figure>

<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理: 无需声明代理类.是使用反射和字节码的技术,在<strong>运行期创建指定接口或类的子类</strong>(即动态代理类) 以及其实例对象的技术.</p>
<p>使用动态代理可以<strong>无侵入的对代码进行增强</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qcFqe.jpg" alt="1qcFqe.jpg"></p>
<p>​            图: java源文件编译生成字节码</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qcAVH.jpg" alt="1qcAVH.jpg"></p>
<p>​                       图: 动态代理生成字节码对象</p>
<h3 id="动态代理的实现方式"><a href="#动态代理的实现方式" class="headerlink" title="动态代理的实现方式"></a>动态代理的实现方式</h3><h4 id="JDK-原生动态代理"><a href="#JDK-原生动态代理" class="headerlink" title="JDK 原生动态代理"></a>JDK 原生动态代理</h4><p>动态代理类和被代理类必须继承同一个接口.动态代理只能对接口中声明的方法进行代理.</p>
<h5 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h5><p>java.lang.reflect.Proxy 是所有动态代理的父类, 它通过静态方法newProxyInstance() 来创建动态代理的class对象 和 实例</p>
<h5 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h5><p>每个动态代理实例都有一个关联的InvocationHandler (程序调用处理者).通过代理实例调用方法,方法调用请求会被转发给 InvocationHandler 的 invoke (调用) 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK动态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJdkDynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建实例</span></span><br><span class="line">        IRegisterService iRegisterService = <span class="keyword">new</span> RegisterServiceImpl();</span><br><span class="line">        <span class="comment">//生成应用调用处理器</span></span><br><span class="line">        RegisterHandler registerHandler = <span class="keyword">new</span> RegisterHandler();</span><br><span class="line">        <span class="comment">//生成代理对象</span></span><br><span class="line">        IRegisterService proxy = (IRegisterService) registerHandler.getProxy(iRegisterService);</span><br><span class="line">        proxy.register(<span class="string">"R1"</span>,<span class="string">"1111"</span>);</span><br><span class="line">        proxy.login(<span class="string">"R2"</span>,<span class="string">"1111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接口</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IRegisterService</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String name,String pwd)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(String name,String pwd)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterServiceImpl</span> <span class="keyword">implements</span> <span class="title">IRegisterService</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String name, String pwd)</span> </span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"【向数据库中插入数据】name：%s，pwd：%s"</span>, name, pwd));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String name, String pwd)</span> </span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"【登录数据】name：%s，pwd：%s"</span>, name, pwd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">        Object object;</span><br><span class="line">        <span class="comment">//获取代理对象的class对象和实例</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.object = object;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            doBefore();</span><br><span class="line">            Object result = method.invoke(object,args);</span><br><span class="line">            doAfter();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"[Proxy]:一些前置处理"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"[Proxy]:一些后置处理"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">Proxy</span>]:<span class="link">一些前置处理</span></span><br><span class="line">【向数据库中插入数据】name：R1，pwd：1111</span><br><span class="line">[<span class="symbol">Proxy</span>]:<span class="link">一些后置处理</span></span><br><span class="line">[<span class="symbol">Proxy</span>]:<span class="link">一些前置处理</span></span><br><span class="line">【登录数据】name：R2，pwd：1111</span><br><span class="line">[<span class="symbol">Proxy</span>]:<span class="link">一些后置处理</span></span><br></pre></td></tr></table></figure>





<h4 id="使用-CGLIB"><a href="#使用-CGLIB" class="headerlink" title="使用 CGLIB"></a>使用 CGLIB</h4><p>JDK代理必须要提供接口,而CGLIB则不需要,可以直接代理类</p>
<blockquote>
<p>待补充…..</p>
</blockquote>
<h3 id="动态代理是什么-应用场景"><a href="#动态代理是什么-应用场景" class="headerlink" title="动态代理是什么? 应用场景?"></a>动态代理是什么? 应用场景?</h3><p>动态代理: 在运行是,创建目标类,可以调用和扩展目标类的方法</p>
<p>Java 中实现动态代理的方式: JDK中的动态代理 和 Java类库 CGLIb</p>
<p>应用场景:</p>
<ul>
<li><p>统计每个 api 的请求耗时,(扩展目标类:调用前加个时间,调用后加个时间)</p>
</li>
<li><p>统一的日志输出</p>
</li>
<li><p>校验被调用的 api 是否已经登录和权限鉴定</p>
</li>
<li><p>Spring 的 AOP 功能模块就是采用动态代理的机制来实现切面编程</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程中的锁</title>
    <url>/2020/02/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类:"></a>锁的分类:</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>很悲观,认为每次去拿数据的时候都认为会修改,所以每次都在拿数据的时候上锁</p>
<a id="more"></a>

<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>synchronized与 Lock interface</p>
<p>Java中实现加锁的方式: 一种是使用synchronized 关键字,另一种是使用Lock 接口的实现类</p>
<p>synchronized 关键字就像是<strong><em>自动档</em></strong> ,可以满足一切驾驶的需求.</p>
<p>但如果你想做更高级的操作,就需要<strong><em>手动挡</em></strong> ,也就是 Lock 接口的实现类.</p>
<h4 id="synchronized-锁升级过程"><a href="#synchronized-锁升级过程" class="headerlink" title="synchronized 锁升级过程:"></a>synchronized 锁升级过程:</h4><p><strong><em>偏向锁  -&gt;  轻量级锁 -&gt; 重量级锁</em></strong></p>
<p> 使用 synchronized 关键字锁住某个代码块时,一开始<strong><em>锁对象</em></strong></p>
<p>(就是下面代码中的object)并不是重量级锁,而是偏向锁.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>偏向锁</em></strong> 的纸面意思就是”<strong><em>偏向于第一个获取它的线程</em></strong>“的锁.线程执行完同步代码块后,并不会主动释放偏向锁.</p>
<p>当第二次达到同步代码块时,线程会判断此时持有锁的线程是否就是自己 (持有锁的线程ID在对象头里存储),如果是则正常往下执行.<strong><em>由于之前没有释放,这里就不需要重新加锁</em></strong>,如果从头到尾都是一个线程在使用锁,很明显偏向锁几乎没有额外开销,性能极高.</p>
<p>一但有第二个线程加入<strong><em>锁竞争</em></strong>, 偏向锁转换为<strong><em>轻量级锁(自旋锁)</em></strong>.只有当某个线程获取锁时,发现锁已经被占用,需要等待其释放,则说明发生了锁竞争.</p>
<p>在轻量级锁的状态下继续锁竞争,没有抢到锁的线程进行<strong><em>自旋</em></strong>  操作,即在一个循环中不断判断是否可以获取锁.</p>
<p>获取锁的操作,就是用过<strong>CAS</strong>操作修改对象头里的锁标志位.先<strong><em>比较</em></strong> 当前锁标志位是否为<strong><em>释放</em></strong>状态,如果是,则将其设置为<strong><em>锁定</em></strong> 状态, CAS 是在JVM层面实现的,是原子性操作.当前线程就算持有了锁,然后线程将<strong>当前锁的持有者信息</strong>改为自己.</p>
<p>假如我们获取到锁的线程操作时间很长,比如会进行复杂的计算,数据量很大的网络传输等;那么其他等待锁的线程就会进入长时间的自旋操作,这个过程是非常耗资源的,这时候<strong>只有一个线程在有效的工作</strong>,其他线程什么都干不了,在白白的消耗 CPU,这种现象叫做<strong><em>忙等</em></strong></p>
<p>显然<strong><em>忙等</em></strong>是有限度的(可通过虚拟机参数更改).如果锁竞争情况严重,达到某个最大自旋次数的线程,会将轻量级锁<strong>升级为重量级锁</strong>(依然是通过CAS修改锁标志位,但不修改持有锁的线程 ID)</p>
<p>当后续线程尝试获取锁时,发现被占用的锁是重量级锁,则直接将自己<strong>挂起</strong>(而不是上面说的忙等,即不会自旋),等待释放锁的线程去唤醒.</p>
<p>JVM中,synchronized 锁只能按照偏向锁,轻量锁,重量锁逐渐升级,不允许降级.</p>
<h4 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h4><p>可重入锁的字面意思是”可以重新进入的锁”,即***运行同一个线程多次获取同一把锁”.</p>
<p>如果不是可重入锁,在递归函数中就会造成死锁,所有Java中的锁基本都是可重入锁</p>
<h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><p>如果多个线程申请一把<strong>公平锁</strong>,那么获得锁的线程释放锁的时候,先申请的先得到,很公平.</p>
<p>如果是<strong>非公平锁</strong>,后申请的线程可能先获得锁,是随机获取还是其他方式,都是根据实现算法而定的.</p>
<p>对于 ReentrantLock类而言,通过构造函数可以<strong>指定该锁是否是公平锁,默认是非公平锁</strong></p>
<p>而对于synchronized 锁而言,它只能是一种非公平锁,没有任何方式使其变成公平锁.</p>
<h4 id="共享锁和互斥锁"><a href="#共享锁和互斥锁" class="headerlink" title="共享锁和互斥锁"></a>共享锁和互斥锁</h4><p>在Java中, ReentrantLock,synchronized 锁都是互斥锁</p>
<p>也有具体的共享锁实例类,如: Semaphore</p>
<h4 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h4><p>字面意思是”可以<strong>响应中断</strong>的锁”</p>
<p>Java的<strong>中断不能直接终止线程</strong>,只是设置了状态为响应中断的状态,需要被中断的线程自己决定怎么处理.</p>
<p>如果线程A持有锁,线程 B 等待获取该锁,由于A持有锁的时间过长,线程B不想继续等,我们可能让线程B中断自己或者在别的线程里面中断 B,这就是可中段锁.</p>
<p>在Java中, synchronize 锁 是<strong>不可中断锁</strong>,而 Lock 的实现类都是<strong>可中断锁</strong></p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote>
<p>很乐观,认为每次去拿数据的时候都不会修改,所以不会上锁</p>
<p>但是如果想更新数据,则会在<strong>更新之前检查在读取至更新这段时间别人有没有修改过这个数据</strong> 如果修改过,这重新读取,再次尝试更新,循环,直到更新成功(当然也允许更新失败的线程放弃更新操作)(CAW)Compare-and-Swap 比较并替换</p>
</blockquote>
<h4 id="乐观锁的基础-—CAS"><a href="#乐观锁的基础-—CAS" class="headerlink" title="乐观锁的基础 —CAS"></a>乐观锁的基础 —CAS</h4><p>CSA? Compare-and-Swap 即比较并替换</p>
<ul>
<li>比较: 读取到一个值 A,在将其更新为 B 之前,检查原值是否为 A</li>
<li>替换: 如果是,更新A为 B.结束. 如果不是,则不会更新.</li>
</ul>
<p>CAS 利用 CPU指令,从硬件上保证了原子性,以达到类似锁的效果.</p>
<p>从乐观锁的整个流程中可以看出,<strong>并没有加锁和解锁</strong>的操作,因此乐观锁策略也被称为<strong>无锁编程</strong>.换句话说,乐观锁其实不是”锁”,它仅仅是一个循环重试的CAS算法而已</p>
<p>在Java中也是通过navtive方法实现的CAS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1,<span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1,<span class="keyword">long</span> var2, <span class="keyword">int</span> var4 ,<span class="keyword">int</span> var5)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1,<span class="keyword">long</span> var2, Long var4,Long var5)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>Java中使用的各种锁基本上是<strong>悲观锁</strong>,Java中的乐观锁在java.util.concurrent.atomic下面的原子类.</p>
<h3 id="怎么预防死锁"><a href="#怎么预防死锁" class="headerlink" title="怎么预防死锁?"></a>怎么预防死锁?</h3><p>为什么会造成死锁:</p>
<ol>
<li>互斥 :任一时刻一个资源只能给一个进程使用</li>
<li>占用等待</li>
<li>非剥夺</li>
<li>循环等待</li>
</ol>
<p>如何防止死锁:</p>
<ul>
<li>尽量使用 tryLick()的方法,设置超时时间,超时可以退出防止死锁</li>
<li>尽量使用Java.util.concurrent 并发类代替自己手写锁</li>
<li>尽量降低锁的使用粒度,尽量不要几个功能用同一把锁</li>
<li>尽量减少同步的代码块</li>
</ul>
<h3 id="synchronized-和-Lock-有什么区别"><a href="#synchronized-和-Lock-有什么区别" class="headerlink" title="synchronized 和 Lock 有什么区别?"></a>synchronized 和 Lock 有什么区别?</h3><ul>
<li>synchronized 可以给类,方法,代码块加锁,而Lock 只能给代码块加锁</li>
<li>synchronized 不需要手动获取锁和释放锁;使用简单,发生异常会自动释放锁,不会造成死锁;而Lock 需要自己加锁和释放锁,如果使用不当,没有 unLock() 区释放就会造成死锁</li>
<li>通过Lock可以知道有没有成功获取锁, 而synchronized却没法办到</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/02/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行?"></a>并发与并行?</h3><p><img src="https://s2.ax1x.com/2020/02/11/1IjNc9.jpg" alt="1IjNc9.jpg"></p>
<a id="more"></a>

<p>并发 = 两个队列和一台咖啡机</p>
<p>并行 = 两个队列和两台咖啡机</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程?"></a>进程与线程?</h3><p><strong>进程 (Process)</strong> 是计算机中的程序关于某数据集合上的一次运行活动,是系统进行资源分配和调度的基本单位,是操作系统的基础.</p>
<p><strong><em>线程(thread)</em></strong> 是操作系统能进行运算调度的最小单位. 它被包含在进程中,是进程中的实际运作单位</p>
<h3 id="创建线程有哪几种方式"><a href="#创建线程有哪几种方式" class="headerlink" title="创建线程有哪几种方式?"></a>创建线程有哪几种方式?</h3><ol>
<li>继承Tread类 重写 run 方法;</li>
<li>实现Runnable 接口;</li>
<li>实现Callable 接口;</li>
</ol>
<h3 id="说一下-Runnable-和-Callable-有什么区别"><a href="#说一下-Runnable-和-Callable-有什么区别" class="headerlink" title="说一下 Runnable 和 Callable 有什么区别?"></a>说一下 Runnable 和 Callable 有什么区别?</h3><p>Runnable 没有返回值, Callable有返回值, Callable 可以看做 Runnable 的补充.</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态?"></a>线程的状态?</h3><p><img src="https://s2.ax1x.com/2020/02/11/1IxrSe.jpg" alt="1IxrSe.jpg"></p>
<ol>
<li>新建(new) : 新创建一个线程对象</li>
<li>可运行状态(Runnaable):  就绪状态,线程对象创建后,被其他线程抢占处理机. 该状态的线程位于可运行线程池中,等待被线程调度选中,获取CPU的使用权.</li>
<li>运行(Running): 可运行状态的线程获得了CPU时间片, 执行程序代码.</li>
<li>阻塞(Blocked): 阻塞状态是指线程因为某种原因放弃了CPU的使用权, 暂时停止运行,直到线程进入可运行状态,才有机会再次获得CPU使用权,转入运行状态.阻塞的情况分为三种<ul>
<li>等待阻塞:  运行的线程执行o.wait()方法,JVM会把该线程放入<strong>等待队列</strong>(waitting queue)中.</li>
<li>同步阻塞: 运行的线程在获取对象的同步锁时,若该同步锁被别的线程占用,则JVM会把该线程放入锁池(lock pool)中.</li>
<li>其他阻塞: 运行的线程执行Thread.sleep() 或<strong>其他线程t2调用 join()</strong> 方法,或者发出I/O请求时,JVM 会把该线程置于阻塞状态.当sleep()状态超时,join() 等待线程终止或超时,或者I/O处理完毕时,线程重新转入可运行状态</li>
</ul>
</li>
<li>死亡(Dead): 线程run(),main() 方法执行结束,或者因异常退出了run()方法,则该线程结束生命周期.死亡的线程不可再生.</li>
</ol>
<blockquote>
<p>等待队列:(本是Object里的方法,但影响了线程)</p>
<p>调用 obje 的 wait(),notify() 方法前,必须获得obj锁 , 也就是必须写在Synchronized(obj)代码块内.</p>
</blockquote>
<h3 id="sleep-好-wait-有什么区别"><a href="#sleep-好-wait-有什么区别" class="headerlink" title="sleep() 好 wait() 有什么区别?"></a>sleep() 好 wait() 有什么区别?</h3><ul>
<li>类的不同: sleep() 来自 Thread, wait() 来自 Object.</li>
<li>释放锁: sleep() 不释放锁; wait()释放锁.</li>
<li>用法不同: sleep() 时间到会自动恢复; wait()可以使用 notify()/notifyAll() 直接唤醒.</li>
</ul>
<h3 id="线程notify-和-notifyAll-有什么区别"><a href="#线程notify-和-notifyAll-有什么区别" class="headerlink" title="线程notify() 和 notifyAll() 有什么区别?"></a>线程notify() 和 notifyAll() 有什么区别?</h3><ul>
<li>notifyAll() 会唤醒所有线程, notify()之后唤醒一个线程(<strong><em>具体唤醒哪个线程由虚拟机控制</em></strong>).</li>
<li>notifyAll() 调用后,会将全部线程由<strong><em>等待池移到锁池</em></strong>,然后参与锁的竞争,竞争成功则继续执行,如果不成功则留在锁池等待锁被释放后再次参与竞争.</li>
</ul>
<h3 id="线程的run-和-start-有什么区别"><a href="#线程的run-和-start-有什么区别" class="headerlink" title="线程的run() 和 start() 有什么区别?"></a>线程的run() 和 start() 有什么区别?</h3><p>start() 方法用于启动线程,run() 方法用于执行线程的运行时代码. run() 可以重复调用,start()只能一次.</p>
<h3 id="线程池都有哪些状态"><a href="#线程池都有哪些状态" class="headerlink" title="线程池都有哪些状态?"></a>线程池都有哪些状态?</h3><p>ThreadPoolExecutor() : 是最原始的线程池创建,一共有7种</p>
<ul>
<li>Running: 这是最正常的状态,接受新的任务,处理等待队列中的任务.</li>
<li>Shutdown: 不接受新的任务提交,但是会继续处理等待队列中的任务.</li>
<li>Stop: 不接受新的任务提交,不再处理等待队列中的任务,中断正在执行任务的线程.</li>
<li>Tidying(整理): 所有的任务都撤销了,workCount为0,线程池状态在转换为Tidying状态时,会执行钩子函数 terminated().</li>
<li>Terminated: terminated() 方法结束后,线程池的状态就会变成这个.</li>
</ul>
<h3 id="线程池中submit-和-execute-方法有什么区别"><a href="#线程池中submit-和-execute-方法有什么区别" class="headerlink" title="线程池中submit() 和 execute()方法有什么区别?"></a>线程池中submit() 和 execute()方法有什么区别?</h3><ul>
<li>execute():  只能执行 Runnable 类型的任务</li>
<li>submit() : 可以执行Runnable 和 Callable类型的任务.</li>
</ul>
<h3 id="在Java程序中怎么保证多线程的运行安全"><a href="#在Java程序中怎么保证多线程的运行安全" class="headerlink" title="在Java程序中怎么保证多线程的运行安全?"></a>在Java程序中怎么保证多线程的运行安全?</h3><ul>
<li>方法一: 使用安全类, 比如 Java.util.concurrent下的类</li>
<li>方法二: 使用自动锁synchronized.</li>
<li>方法三: 使用手动锁Lock.</li>
</ul>
<p>就总结到这把,下一次写Java中的各种锁吧,然后再结合锁来处理多线程的问题!</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 容器</title>
    <url>/2020/02/10/Java-%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="Java容器都有哪些"><a href="#Java容器都有哪些" class="headerlink" title="Java容器都有哪些?"></a>Java容器都有哪些?</h2><p>Java容器分为Collection 和 Map 两大类,其下又有很多子类</p>
<a id="more"></a>

<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection:"></a>Collection:</h3><ul>
<li>List</li>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector                 //线程安全</li>
<li>Stack                  //线程安全</li>
<li>Set</li>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map:"></a>Map:</h3><ul>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
<li>Hashtable                     //线程安全</li>
<li>ConcurrentHashMap    多线程下使用的并发HashMap,在java.util.concurrent下</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/10/14X4Fe.jpg" alt="14X4Fe.jpg"></p>
<h2 id="Collection-和-Collections有什么区别"><a href="#Collection-和-Collections有什么区别" class="headerlink" title="Collection 和 Collections有什么区别?"></a>Collection 和 Collections有什么区别?</h2><ul>
<li>Collection是一个集合接口,它提供了对集合对象进行基本操作的通用接口方法,所有集合都是他的子类,比如List,Set等.</li>
<li>Collections是一个包装类,包含了很多静态方法,不能被实例化,就像一个工具类,比如提供的排序方法: Collections.sort(list).</li>
</ul>
<h2 id="说一下-HashMap的实现原理"><a href="#说一下-HashMap的实现原理" class="headerlink" title="说一下 HashMap的实现原理"></a>说一下 HashMap的实现原理</h2><p>HashMap基于Hash算法实现:</p>
<p>我们通过put(key,value)存储,get(key)来获取.当传入key是,HashMap会根据key.hashCode()计算出 hash 值.</p>
<p>根据hash值将value 保存在 bucket(桶)里,当计算出的hash值相同时,hash冲突,HashMap的做法是用链表和红黑树存储相同的hash值的value.当hash冲突的个数比较少时,使用链表,当数量增长到一定长度链表就转化为红黑树.</p>
<p><img src="https://s2.ax1x.com/2020/02/10/14LnSI.png" alt="14LnSI.png"></p>
<h2 id="说一下HashSet的实现原理"><a href="#说一下HashSet的实现原理" class="headerlink" title="说一下HashSet的实现原理?"></a>说一下HashSet的实现原理?</h2><p>HashSet是基于HashMap实现的,HashSet底层使用HashMap来保存所有元素,因此HashSet的实现比较简单,相关HashSet的操作,基本上都是直接调用底层的HashMap的相关方法来完成,HashSet不允许出现重复</p>
<h2 id="ArrayList-和-LinkedList-的区别是什么"><a href="#ArrayList-和-LinkedList-的区别是什么" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么?"></a>ArrayList 和 LinkedList 的区别是什么?</h2><ul>
<li>数据机构的实现:  ArrayList是<strong><em>动态数组</em></strong>的数据结构实现,而LinkedList是双向链表的数据结构实现.</li>
<li>随机访问效率: ArrayList 比 LinkedList在随机访问的时候效率高,因为LinkedList是线性的数据存储方式,所以需要移动指针从前往后依次查找</li>
<li>增加和删除效率: 在非收尾的增加和删除操作,LinkedList要比ArrayList效率要高,因为ArrayList是动态数组实现,增删操作会影响数组内后面数据的下标.</li>
</ul>
<h2 id="如何实现数组与List之间的转换"><a href="#如何实现数组与List之间的转换" class="headerlink" title="如何实现数组与List之间的转换"></a>如何实现数组与List之间的转换</h2><ul>
<li>数组转List:  使用Arrays.asList(array)进行转换</li>
<li>List转数组: 使用List自带的toArray()方法</li>
</ul>
<blockquote>
<p>迭代器Iterator  Collection接口继承了Iterator接口</p>
<p>Iterator的特点是更加安全,因为他可以确保,在当前遍历的集合元素被更改的时候,就会抛出<code>ConcurrentModificationException</code>异常</p>
</blockquote>
<h2 id="在Queue中-poll-和-remove-有什么区别"><a href="#在Queue中-poll-和-remove-有什么区别" class="headerlink" title="在Queue中 poll()和 remove()有什么区别?"></a>在Queue中 poll()和 remove()有什么区别?</h2><ul>
<li>相同点: 都是返回第一个元素,并在队列中删除返回的对象</li>
<li>不同点: 如果没有元素poll() 会返回null , 而 remove() 会直接抛出 NoSuchElementException异常.</li>
</ul>
<h2 id="如何确保一个集合不能被修改"><a href="#如何确保一个集合不能被修改" class="headerlink" title="如何确保一个集合不能被修改?"></a>如何确保一个集合不能被修改?</h2><p>可以使用Collections.unmodifiableCollection(Collection c) 方法来创建一个只读的集合,这样改变集合的任何操作都会抛出Java.lang.UnsupportedOperationException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"x"</span>);</span><br><span class="line">Collection&lt;String&gt; collection=Collections.unmodifiableCollection(list);</span><br><span class="line">collection.add(<span class="string">"y"</span>);</span><br><span class="line">System.out.println(collection.size());</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>map</tag>
        <tag>容器</tag>
        <tag>set</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>map的分类和常见情况</title>
    <url>/2020/02/09/map%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p>java 数据结构中映射定义了一个接口java.util.Map</p>
<p>它有四个实现类:</p>
<ol>
<li>HashMap</li>
<li>Hashtable</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
</ol>
<a id="more"></a>

<p>Map主要用于存储键值对,根据键得到值,因此不允许键重复,但允许值重复</p>
<h3 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h3><p>Hashmap是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值,具有很快的访问速度.</p>
<p>遍历时,<strong><em>取得数据的顺序是完全随机</em></strong>的.</p>
<p>HashMap最多只允许一条记录的键为Null;</p>
<p>HashMap<strong><em>不支持线程的同步</em></strong>,即任一时刻可以有多个线程同时写HashMap,可能导致数据不一致.</p>
<p>如果需要同步,可以用Collections的synchronizedMap方法使HashMap具有同步能力,或者使用ConcurrentHashMap.</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable与HashMap类似,它继承自Dictionary类,</p>
<p>不同的是: 它不允许记录的键或者值为空,它<strong><em>支持线程的同步</em></strong>,即任一时刻只有一个线程能写Hashtable,因此也导致了Hashtable在写入时会比较慢.</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap是HashMap的一个子类,保存了记录的插入顺序,在用Iterator遍历LinkedHashMap时,先得到的记录肯定是先插入的,也可以在构造时用带参数,按照应用次数排序.</p>
<p>在遍历时会比HashMap慢,不过有种情况例外,当HashMap容量很大,实际数据较少时,遍历起来可能会比LinkedHashMap慢,因为LinkedHashMap的遍历速度只与实际数据有关,和容量无关,而HashMap的遍历速度和它的容量有关.</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>*<em>线程不安全 *</em></p>
<p>TreeMap实现SortMap接口,基于红黑树的,能够把它保存的记录根据键排序,默认是按键值的升序排序,也可以指定排序的比较器,当用Iterator遍历TreeMap时,得到的记录是排过序的.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p>
<p>HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。</p>
<p>HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</p>
<p>Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。</p>
<p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。</p>
<p>在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql锁</title>
    <url>/2020/02/08/Mysql%E9%94%81/</url>
    <content><![CDATA[<h2 id="宏观"><a href="#宏观" class="headerlink" title="宏观"></a>宏观</h2><h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁　"></a>数据库锁　</h3><pre><code>粒度小，方便用于集群环境</code></pre><h3 id="代码锁"><a href="#代码锁" class="headerlink" title="代码锁"></a>代码锁</h3><pre><code>粒度大，需要封装</code></pre><a id="more"></a>

<h2 id="微观"><a href="#微观" class="headerlink" title="微观"></a>微观</h2><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h4 id="行锁＆表锁"><a href="#行锁＆表锁" class="headerlink" title="行锁＆表锁"></a>行锁＆表锁</h4><p><strong><em>只有明确指定主键，才会执行行锁，否则执行表锁</em></strong></p>
<blockquote>
<p>无锁</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主键不存在</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">-1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>行锁</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主键明确</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">'kkk'</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>表锁</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主键不明确</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'kkk'</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt;&gt; <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<h2 id="锁算法"><a href="#锁算法" class="headerlink" title="锁算法"></a>锁算法</h2><h3 id="行锁算法"><a href="#行锁算法" class="headerlink" title="行锁算法"></a>行锁算法</h3><p> Record Lock:单个行记录上的锁</p>
<ul>
<li>键值在条件范围内</li>
<li>记录存在</li>
</ul>
<p>Gap Lock:间隙锁</p>
<ul>
<li>锁定一个范围,但不包含记录本身</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#id只有1-50</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">50</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>


<p>Next-Key Lock:(行&amp;间隙)</p>
<ul>
<li>锁定一个范围,并且锁定记录本身<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#id只有1-50</span></span><br><span class="line">  <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">id</span>&gt;<span class="number">49</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<h3 id="表锁算法"><a href="#表锁算法" class="headerlink" title="表锁算法"></a>表锁算法</h3>意向锁(升级机制)</li>
<li>当一个事务带着表锁去访问一个加了行锁的资源,那么,此时这个行锁就会升级成意向锁,将表锁住.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#事务A -升级表锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;  //此时是行锁</span><br><span class="line"><span class="comment">#事务B -锁表</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'kkk'</span> <span class="keyword">for</span> <span class="keyword">update</span>;//升级表锁</span><br></pre></td></tr></table></figure>
<p>自增锁</p>
<ul>
<li>事务插入自增类型的列时,获取自增锁<blockquote>
<p>  如果一个事务正在往表中插入自增记录,其他事务都必须等待,对于有自增长值的列的并发插入性能较差,事务必须等待</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java查漏补缺</title>
    <url>/2020/02/08/Java%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<h2 id="String-StringBuffer-StringBuilder的区别"><a href="#String-StringBuffer-StringBuilder的区别" class="headerlink" title="String StringBuffer StringBuilder的区别"></a>String StringBuffer StringBuilder的区别</h2><ol>
<li>操作数量较少的字符串用String，不可修改的字符串；</li>
<li>在多线程且操作大量字符串用StringBuffer，线程安全，可修改。</li>
<li>在单线程且操作大量字符串用StringBuilder,速度快，但线程不安全，可修改； <a id="more"></a>

</li>
</ol>
<h2 id="变量存放在哪"><a href="#变量存放在哪" class="headerlink" title="变量存放在哪?"></a>变量存放在哪?</h2><p>基本数据类型是放在栈中还是放在堆中，这取决于基本类型在何处声明，下面对数据类型在内存中的存储问题来解释一下：</p>
<p>   一：在<strong>方法中声明的变量</strong>，即该变量是局部变量，每当<strong>程序调用方法时</strong>，系统都会为该方法建立一个<strong>方法栈</strong>，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因</p>
<pre><code>在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。

   （1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中

   （2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）
       是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</code></pre><p>   二：在类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。</p>
<pre><code>同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量

（1）当声明的是基本类型的变量其变量名及其值放在堆内存中的

（2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。
      引用变量名和对应的对象仍然存储在相应的堆中</code></pre><h2 id="请你讲讲数组-Array-和列表-ArrayList-的区别？"><a href="#请你讲讲数组-Array-和列表-ArrayList-的区别？" class="headerlink" title="请你讲讲数组(Array)和列表(ArrayList)的区别？"></a>请你讲讲数组(Array)和列表(ArrayList)的区别？</h2><ol>
<li>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型(对基本类型实现自动装箱)。</li>
<li>Array大小是固定的，ArrayList的大小是动态变化的。</li>
<li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</li>
</ol>
<h2 id="请你解释什么是值传递和引用传递？"><a href="#请你解释什么是值传递和引用传递？" class="headerlink" title="请你解释什么是值传递和引用传递？"></a>请你解释什么是值传递和引用传递？</h2><ul>
<li><p>值传递是针对基本变量而言,传递的是该变量的一个副本,改变副本不影响原变量</p>
</li>
<li><p>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象</p>
</li>
<li><p>一般认为,java内的传递都是值传递.</p>
<p>在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。<br>只是在传递过程中：</p>
<p><strong>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</strong></p>
<p><strong>如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</strong></p>
</li>
</ul>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类也就是没有名字的内部类<br>正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写</p>
<p>但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到,我们直接将抽象类Person中的方法在大括号中实现了<br>这样便可以省略一个类的书写<br>匿名内部类还可以直接作用于接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  <span class="comment">//多线程匿名内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java8-新特性"><a href="#java8-新特性" class="headerlink" title="java8 新特性"></a>java8 新特性</h2><ol>
<li>lambda表达式 : 允许函数作为另一个方法的参数</li>
<li>方法引用: 可以直接引用已有Java类或实例的方法或构造器</li>
<li>默认方法: 在一个接口里有了一个默认的实现方法</li>
<li>新工具: 新的编译工具和类依赖分析工具</li>
<li>Stream API: 把真正的函数式编程引入java</li>
<li>Date Time API :加强对日期时间的处理</li>
<li>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>avaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用</li>
</ol>
<h2 id="HashCode-Object的默认HashCode-是什么-为什么重写equals-还要重写hashCode"><a href="#HashCode-Object的默认HashCode-是什么-为什么重写equals-还要重写hashCode" class="headerlink" title="HashCode Object的默认HashCode()是什么?为什么重写equals() 还要重写hashCode()?"></a>HashCode Object的默认HashCode()是什么?为什么重写equals() 还要重写hashCode()?</h2><ul>
<li>Object 的HashCode()方法是<strong>本地方法</strong>,即使用C/C++实现的,该方法直接返回对象的<strong>内存地址</strong></li>
<li>首先我们要知道HashMap()比较key的时候的过程:</li>
</ul>
<ol>
<li>先求出key的HashCode值,判断是否相等</li>
<li>若相等再判断equals()是否相等,若相等则认为是相等的</li>
</ol>
<blockquote>
<p>现在有两个Student对象：</p>
</blockquote>
<pre><code>Student s1=new Student(&quot;小明&quot;,18);

Student s2=new Student(&quot;小明&quot;,18);</code></pre><p>此时,如果不重写equals方法,s1.equals(s2)为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object 源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//可知equals的本质就是 == </span></span><br><span class="line"><span class="comment">//String 和包装类都重写了 equals方法</span></span><br></pre></td></tr></table></figure>



<p>假如只重写equals而不重写hashcode，那么Student类的hashcode方法就是Object默认的hashcode方法，由于默认的hashcode方法是<strong>本地方法</strong>是根据<strong>对象的内存地址</strong>经哈希算法得来的，显然此时<strong>s1!=s2</strong>,故两者的hashcode不一定相等。</p>
<blockquote>
<p>HashCode判断key相等,实际上是调用了HashSet()方法.</p>
</blockquote>
<p>重载hashCode()是为了对同一个key，能得到相同的Hash Code，这样HashMap就可以定位到我们指定的key上</p>
<h2 id="Java中的Math-round-1-5-等于多少"><a href="#Java中的Math-round-1-5-等于多少" class="headerlink" title="Java中的Math.round(-1.5)等于多少"></a>Java中的Math.round(-1.5)等于多少</h2><blockquote>
<p>Math.round(-1.5)的返回值是-1</p>
<p>四舍五入的原理是在参数上加0.5然后向下取整</p>
</blockquote>
<h2 id="String-str-“i”-与-String-str-new-String-“i”-一样吗"><a href="#String-str-“i”-与-String-str-new-String-“i”-一样吗" class="headerlink" title="String str = “i” 与 String str = new String(“i”)一样吗?"></a>String str = “i” 与 String str = new String(“i”)一样吗?</h2><p><a href="https://imgchr.com/i/14y5TS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/10/14y5TS.md.png" alt="14y5TS.md.png"></a></p>
<p><strong>堆</strong>：存放对象的实例以及对象的属性和方法</p>
<p><strong>栈</strong>：储存基本数据类型的值、执行的方法、方法中声明的变量、数组、对象的引用(reference类型)</p>
<p><strong>方法区</strong>：存储已被虚拟机加载的类元数据信息(元空间)</p>
<p><strong>运行时常量池</strong>：常量(final)、字符串</p>
<p>String str=”i”: Java虚拟机会将其分配到<strong><em>常量池</em></strong>中;</p>
<p>String str = new String(“i”) : 则会分到<strong><em>堆内存</em></strong>中,即使内容一样还是会创建新对象</p>
<p>在常量池中没有重复的元素,Java虚拟机会先在常量池中检索是否已经存在,如果有那么就直接赋值地址,如果没就创建一个,然后再赋给变量;</p>
<h2 id="抽象类与接口和普通类的区别"><a href="#抽象类与接口和普通类的区别" class="headerlink" title="抽象类与接口和普通类的区别"></a>抽象类与接口和普通类的区别</h2><ol>
<li>抽象类要被子类继承,接口要被类实现</li>
<li>接口只能做方法声明,抽象类中可以作方法声明,也可以做方法实现</li>
<li>接口里定义的变量只能是公共的静态的变量,抽象类中的变量是普通变量</li>
<li>抽象类可以有具体的方法和属性,接口只能有抽象方法和不可变常量.</li>
<li>构造函数: 抽象类可以有构造函数;接口不能有</li>
<li>抽象类不能直接实例化,普通类可以直接实例化</li>
</ol>
<h2 id="Java中的IO流分几种"><a href="#Java中的IO流分几种" class="headerlink" title="Java中的IO流分几种?"></a>Java中的IO流分几种?</h2><p>字节流和字符流.</p>
<p>字节流和字符流的区别是: 字节流按8位传输以字节为单位输入输出数据,字符流按16位字符为单位输入输出数据.</p>
<h2 id="BIO-NIO-AIO有什么区别"><a href="#BIO-NIO-AIO有什么区别" class="headerlink" title="BIO,NIO,AIO有什么区别?"></a>BIO,NIO,AIO有什么区别?</h2><ul>
<li>BIO: Block IO同步阻塞式IO,就是平常使用的IO,它的特点是模式简单使用方便,并发处理能力低.</li>
<li>NIO: Non IO同步非阻塞IO, 是传统的IO的升级,客户端和服务器端通过Channel(通道) 通讯,实现了多路复用.</li>
<li>AIO: Asynchronous IO 是NIO的升级,也叫NIO2,实现了异步非阻塞IO,异步IO的操作基于事件和回调机制.</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>se</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql数据库隔离级别</title>
    <url>/2020/02/08/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h1><p>事务只是一个改变,是<strong>一些操作的集合</strong>;<br>用专业的术语讲,它就是一个程序的执行单元;<br><strong>事务本身其实并不包括这4个特性</strong>,我们需要通过某些手段,尽可能的让这个执行单元满足这四个特性,那么我们就称他为一个事务,或者说是一个正确的事务</p>
<a id="more"></a>


<h1 id="2-四特性"><a href="#2-四特性" class="headerlink" title="2,四特性"></a>2,四特性</h1><ol>
<li>原子性:满足原子操作单元,对数据的操作,要么全部执行,要么全部失败</li>
<li>一致性: 从一个正确的状态迁移到另一个正确的状态   <strong><em>一致性是目的</em></strong> AID是为了保证C</li>
<li>隔离性:事务之间是相互独立的,中间状态是不可见的</li>
<li>持久性:数据的修改是永久的</li>
</ol>
<h1 id="3-隔离级别"><a href="#3-隔离级别" class="headerlink" title="3,隔离级别"></a>3,隔离级别</h1><h2 id="3-1-并发情况下事务引发的问题"><a href="#3-1-并发情况下事务引发的问题" class="headerlink" title="3.1 并发情况下事务引发的问题"></a>3.1 并发情况下事务引发的问题</h2><pre><code>一般情况下,多个单元操作并发执行,会出现这么几个问题</code></pre><ol>
<li><p>脏读:A事务还未提交,B事务就读到了A事务的结果.(破坏了隔离性)</p>
</li>
<li><p>不可重复读:A事务在本次事务中,对自己未操作过的数据,进行了多次读取,结果出现了不一致或记录不存在的情况.(破坏了一致性,update和delete)<strong>指在事务1内，读取了一个数据，事务1还没有结束时，事务2也访问了这个数据，修改了这个数据，并提交。紧接着，事务1又读这个数据。由于事务2的修改，那么事务1两次读到的的数据可能是不一样的，因此称为是不可重复读。</strong></p>
</li>
<li><p>幻读:A事务在本次事务中,对自己未操作过的数据,进行了多次读取,第一次读取时,记录不存在,第二次读取时,记录出现了.(破坏了一致性,insert)</p>
</li>
</ol>
<h2 id="3-2解决-制定标准"><a href="#3-2解决-制定标准" class="headerlink" title="3.2解决(制定标准)"></a>3.2解决(制定标准)</h2><p>为了权衡<strong>隔离</strong>与<strong>并发</strong>的矛盾,ISO定义了四个事务的隔离机制,每个级别的隔离程度不同,允许出现的副作用也不同</p>
<ol>
<li>未提交读(read-uncommitted):最低级别,只能保证持久性</li>
<li>提交读(read-committed):语句级别的</li>
<li>可重复读(repeatable-read):事务级别</li>
<li>串行化(serializable):最高级别,事务与事务完成串行化执行,毫无并发可言,性能极低</li>
</ol>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读</td>
<td>会</td>
<td>会</td>
<td>会</td>
</tr>
<tr>
<td>提交读</td>
<td>-</td>
<td>会</td>
<td>会</td>
</tr>
<tr>
<td>可重复读</td>
<td>-</td>
<td>-</td>
<td>会</td>
</tr>
<tr>
<td>串行化</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>注意:这四个级别只是一个标准,各个数据库厂商,并不是完全按照这个标准来做的</p>
<p><code>&lt;https://blog.csdn.net/Vincent2014Linux/article/details/89669762&gt;</code></p>
<p>这篇博客总结的非常好</p>
<h2 id="3-3-实现-InnoDB"><a href="#3-3-实现-InnoDB" class="headerlink" title="3.3 实现(InnoDB)"></a>3.3 实现(InnoDB)</h2><h3 id="1-锁机制-阻止事务对数据的操作-各个隔离级别主要体现在读取数据时加的锁和释放时机"><a href="#1-锁机制-阻止事务对数据的操作-各个隔离级别主要体现在读取数据时加的锁和释放时机" class="headerlink" title="1. 锁机制:阻止事务对数据的操作,各个隔离级别主要体现在读取数据时加的锁和释放时机"></a>1. 锁机制:阻止事务对数据的操作,各个隔离级别主要体现在读取数据时加的锁和释放时机</h3><ul>
<li>RU:事务读取的时候不加锁</li>
<li>RC: 事务读取的时候加行级共享锁(读到才加锁),一旦读完,立刻释放(并不是事务结束).</li>
<li>RR: 事务读取时加行级共享锁,直到事务结束才会释放</li>
<li>SE: 事务读取是加表级共享锁,直到事务结束才会释放<h3 id="2-MVCC机制-生成一个数据快照-并用这个快照来提供一定级别的一致性的读取-也成为了多版本数据控制"><a href="#2-MVCC机制-生成一个数据快照-并用这个快照来提供一定级别的一致性的读取-也成为了多版本数据控制" class="headerlink" title="2. MVCC机制:生成一个数据快照,并用这个快照来提供一定级别的一致性的读取,也成为了多版本数据控制."></a>2. MVCC机制:生成一个数据快照,并用这个快照来提供一定级别的一致性的读取,也成为了多版本数据控制.</h3></li>
<li>实际就是<strong>CAS版本控制</strong>和<strong>读写分离</strong>的思想</li>
<li>主要作用于RC和RR级别</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
