<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM内存模块</title>
    <url>/2020/02/26/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdn.net/20180812235058303" alt="img"></p>
<a id="more"></a>

<h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><ul>
<li>当前线程所执行的字节码行号指示器（逻辑）</li>
<li>通过改变计数器的值来选取下一条需要执行的字节码指令</li>
<li>和线程一对一的关系，即“线程私有”</li>
<li>对 Java 方法计数，如果是 Native 方法则计数器值为 Undefined</li>
<li>只是计数，不会发生内存泄漏</li>
</ul>
<h3 id="Java-虚拟机栈-方法栈"><a href="#Java-虚拟机栈-方法栈" class="headerlink" title="Java 虚拟机栈(方法栈)"></a>Java 虚拟机栈(方法栈)</h3><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://gitee.com/duhouan/ImagePro/raw/master/JVM/8442519f-0b4d-48f4-8229-56f984363c69.png" alt="img"></p>
<p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">java -Xss512M HackTheJavaCopy <span class="keyword">to</span> clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
<blockquote>
<p>局部变量表和操作数栈</p>
</blockquote>
<ul>
<li>局部变量表：包含方法执行过程中的所有变量</li>
<li>操作数栈：入栈、出栈、复制、交换、产生消费变量</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">JVMTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">int</span> add(<span class="built_in">int</span> a ,<span class="built_in">int</span> b) &#123;</span><br><span class="line">        <span class="built_in">int</span> c = <span class="number">0</span>;</span><br><span class="line">        c = a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">javap </span>-verbose <span class="keyword">JVMTestCopy </span>to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://gitee.com/duhouan/ImagePro/raw/master/JVM/j_1.png" alt="img"></p>
<p>解读上述指令：</p>
<ul>
<li>stack = 2 说明栈的深度是 2 ；locals = 3 说明有 3 个本地变量 ；args_size = 2 说明该方法需传入 2 个参</li>
<li>load 指令表示入操作数栈，store 表示出操作数栈</li>
</ul>
<p>执行 add(1,2)，说明局部变量表和操作数栈的关系：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://gitee.com/duhouan/ImagePro/raw/master/JVM/j_2.png" alt="img"></p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://gitee.com/duhouan/ImagePro/raw/master/JVM/66a6899d-c6b0-4a47-8569-9d08f0baf86c.png" alt="img"></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（Old Generation）</li>
</ul>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJavaCopy <span class="keyword">to</span> clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java 内存分配策略</p>
</blockquote>
<p>1、静态存储：编译时确定每个数据目标在运行时的存储空间需求</p>
<p>2、栈式存储：数据区需求在编译时未知，运行时模块入口前确定</p>
<p>3、堆式存储：编译时或运行时模块入口都无法确定，动态分配</p>
<blockquote>
<p><strong>问题一：堆和栈的联系</strong></p>
</blockquote>
<p>引用对象、数组时，栈里定义变量保存堆中目标的首地址。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://gitee.com/duhouan/ImagePro/raw/master/JVM/j_3.png" alt="img"></p>
<blockquote>
<p><strong>问题二：栈和堆的区别</strong></p>
</blockquote>
<ul>
<li><p>物理地址</p>
<p>堆的物理内存分配是不连续的；</p>
<p>栈的物理内存分配是连续的</p>
</li>
<li><p>分配内存</p>
<p>堆是不连续的，分配的内存是在运行期确定的，大小不固定；</p>
<p>栈是连续的，分配的内存在编译器就已经确定，大小固定</p>
</li>
<li><p>存放内容</p>
<p>堆中存放的是对象和数组，关注的是数据的存储；</p>
<p>栈中存放局部变量，关注的是程序方法的执行</p>
</li>
<li><p>是否线程私有</p>
<p>堆内存中的对象对所有线程可见，可被所有线程访问；</p>
<p>栈内存属于某个线程私有的</p>
</li>
<li><p>异常</p>
<p>栈扩展失败，会抛出 StackOverflowError；</p>
<p>堆内存不足，会抛出 OutOfMemoryError</p>
</li>
</ul>
<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p>
<p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。<strong>元空间存储类的元信息，静态变量和常量池等放入堆中</strong>。</p>
<blockquote>
<p>元空间（MetaSpace）与永久代（PermGen）的区别</p>
</blockquote>
<p>元空间使用本地内存，而永久代使用 JVM 的内存。</p>
<blockquote>
<p>元空间（MetaSpace）相比永久代（PermGen）的优势</p>
</blockquote>
<p>1、字符串常量池存在永久代中，容易出现性能问题和内存溢出</p>
<p>2、类和方法的信息大小难以确定，给永久代的大小指定带来困难</p>
<p>3、永久代会为 GC 带来不必要的复杂性</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是元空间的一部分。</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
<p>直接内存</p>
<p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h2 id="JVM常见参数"><a href="#JVM常见参数" class="headerlink" title="JVM常见参数"></a>JVM常见参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-Xss</td>
<td>规定了每个线程虚拟机栈（堆栈）的大小，会影响并发线程数的大小</td>
</tr>
<tr>
<td>-Xms</td>
<td>堆的初始值</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆能达到的最大值</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>动态数组,链表,栈,队列</title>
    <url>/2020/02/24/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8-%E6%A0%88-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 动态数组</li>
<li><input checked="" disabled="" type="checkbox"> 栈 (方法栈,括号匹配)</li>
<li><input checked="" disabled="" type="checkbox"> 队列</li>
<li>普通队列</li>
<li>循环队列</li>
<li><input checked="" disabled="" type="checkbox"> 链表</li>
</ul>
<a id="more"></a>

<p><strong>栈和队列</strong>可以使用<strong>动态数组</strong>实现,也可以使用<strong>链表</strong>实现</p>
<p>动态数组底层是静态数组,只是多了size (元素数量,并指向尾部) 实现了扩容和缩容</p>
<p>扩容操作的源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList初始化:如果不指定初始化大小,elementData[]的默认容量大小为10</p>
<p>当size &gt; 10时, newCapacity = oldCapacity +(oldCapacity &gt;&gt; 1),右移 /2,所有是扩容为原来的1.5倍</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>java中 LinkedList是一个双向链表</p>
<p>没啥好说的,注意循环队列底层是静态数组,要自己进行扩容:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环队列有一个空缺 ,创建时多分一个空间</span></span><br><span class="line"><span class="comment">// tail == front 队列为空</span></span><br><span class="line"><span class="comment">//  (tail + 1) % capacity == front 时 队满</span></span><br></pre></td></tr></table></figure>

<p>LinkedListQueue: 指向头,尾节点的链表.</p>
<h3 id="ArrayDequeue"><a href="#ArrayDequeue" class="headerlink" title="ArrayDequeue"></a>ArrayDequeue</h3><p>ArrayDeque是JDK容器中的一个双端队列实现，内部使用数组进行元素存储，不允许存储null值，可以高效的进行元素查找和尾部插入取出，是用作队列、双端队列、栈的绝佳选择，性能比LinkedList还要好。听到这里，不熟悉ArrayDeque的你是不是有点尴尬？JDK中竟然还有这么好的一个容器类？<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://images2018.cnblogs.com/blog/1043143/201809/1043143-20180906234002055-1594361289.png" alt="img"></p>
<p>　　别慌，现在了解还来得及，趁响指还没有弹下去，快上车吧，没时间解释了。<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://images2018.cnblogs.com/blog/1043143/201809/1043143-20180906234013374-502253597.png" alt="img"></p>
<p>　<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://images2018.cnblogs.com/blog/1043143/201809/1043143-20180906225435344-951172641.png" alt=""></p>
<p>ArrayDeque是继承自Deque接口，Deque继承自Queue接口，Queue是队列，而Deque是双端队列，也就是可以从前或者从后插入或者取出元素，也就是比队列存取更加方便一点，单向队列只能从一头插入，从另一头取出</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的简单使用</title>
    <url>/2020/02/23/Docker%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/23/3ltGCQ.png" alt="3ltGCQ.png"></p>
<a id="more"></a>

<ol>
<li>镜像: 类似于虚拟机,创建虚拟机之前需要下载的系统镜像文件,是image格式</li>
<li>容器: 可以类比为一个<strong>正在运行的虚拟机</strong>,是进程隔离的</li>
<li>tar文件: 可以将一个镜像直接保存为一个tar 文件, 然后可以给别人,通过load指令,重新加载成一个镜像</li>
<li>Dockerfile:  镜像的配置文件,通过写<strong>如何构建</strong> 的步骤,来指定一个镜像是如何构建的</li>
<li>仓库: 第三方镜像,官方镜像,可以直接pull下来,也可以push自己的</li>
</ol>
<blockquote>
<p>使用阿里云docker镜像加速</p>
</blockquote>
<p>从远端仓库拉取</p>
<p>docker pull nginx : 版本号(不指定版本为最新版本)</p>
<p>docker images     查看镜像信息</p>
<p>docker run -d -p 80:80  –name 指定运行起来的名字  -v 文件映射  nginx   ;</p>
<p>运行 -d 后台运行不占用终端 ,-p 外:内端口映射    image名称 </p>
<p>docker run -d -p 81:80 nginx  ;此时有两个nignx在运行,分别在81端口和80端口</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/23/3lfsiQ.png" alt="3lfsiQ.png"></p>
<p>docker exec -it (image id)  bash</p>
<p>进入到镜像中,此时可以使用镜像配置</p>
<p>更改后退出回到本地系统 exit()</p>
<p>docker ps       : 查看正在运行的image</p>
<p>docker rm -f  (image id) : 删除一个 运行中的image</p>
<p><strong>-f :</strong>通过 SIGKILL 信号强制删除一个运行中的容器。</p>
<p>docker commit  (进程id)  (指定image 名称)</p>
<p>从运行中的容器提取一个出来做成image,修改后的容器commit后再运行会是你修改后的</p>
<h3 id="Dockerfile-语法"><a href="#Dockerfile-语法" class="headerlink" title="Dockerfile 语法"></a>Dockerfile 语法</h3><hr>
<p>FROM    基础镜像:版本号    </p>
<p>WORKDIR       /app  #工作目录,没有就会创建</p>
<p>COPY      src/      /app     #将宿主机下src下的文件 复制到/app下</p>
<p>RUN      echo 321 &gt;&gt; 1.txt   #指定一个运行时(构建时)的脚本</p>
<p>CMD       tail -f 1.txt        #指定脚本,运行完这个脚本后系统构建完毕</p>
<p><strong>除了from其他都是非必须的</strong></p>
<hr>
<p>docker build -t n2  .     n2表示镜像名,    .  指定当前目录下的Dockerfile去构建</p>
<p>docker  save (镜像名)  -&gt; 1.tar </p>
<p>将镜像压缩打包,别拿到文件后可以直接load</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie 与 session</title>
    <url>/2020/02/22/Cookie-%E4%B8%8E-session/</url>
    <content><![CDATA[<p>刚刚刷知乎,看见了这个问题,翻到一篇非常好的答案,记录一下</p>
<p>session的常见实现要借助cookie来发送sessionID.</p>
<h3 id="cookie的简介"><a href="#cookie的简介" class="headerlink" title="cookie的简介"></a>cookie的简介</h3><ul>
<li>cookie是Web服务器保存在客户端的一系列文本信息</li>
<li>cookie的作用<ul>
<li>对特定对象的追踪</li>
<li>统计网页浏览次数</li>
<li>简化登录</li>
</ul>
</li>
<li>安全性能：容易信息泄露</li>
</ul>
<a id="more"></a>

<h3 id="Session是什么"><a href="#Session是什么" class="headerlink" title="Session是什么"></a>Session是什么</h3><p><strong>用途</strong></p>
<ol>
<li>Session可以记录用户的登录与行为数据，即记录下用户目前访问服务器上的那些内容，状态是什么，而考虑到这些数据用户修改的随意性很大，并没有必要直接存储在数据库中。</li>
<li>在用户执行刷新操作时，即再次访问服务器时，可以直接根据Session，打开用户上次访问时网页的状态（如用户输入的表单内容等等），为用户带来更优的体验，提供个性化服务。</li>
<li>用户的session信息非常关键，它记录了用户在进入页面、查看结果、点击结果以及后继的操作（比如翻页、加购物车等）。只有通过session信息才能把用户的行为联系起来，构建出完整的模型，因此从海量数据中把每一个用户所有session的操作都完整地挖掘出来非常重要。</li>
</ol>
<p>Session其实就是会话变量的保存地，只要是能使用变量的地方，都能使用 Session 变量。比如可以用来 计数、存储临时信息、甚至还可以存储DataTable，只要你的服务器的内存足够大就行。 简单通俗的讲session就是象一个临时的容器 来存放这些临时的东西 从你登陆开始就保存在session里 当然你可以自己设置它的有效时间和页面 举个简单的例子 我们做一个购书的JSP网站 顾客买书的时候会挑选出一些书 但是在付钱之前还可以修改,所以不能存到数据库 就可以先保存在session里 等到确认了以后再放入数据库…</p>
<p>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； </p>
<p>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，<strong>实际上大多数的应用都是用 Cookie 来实现Session跟踪的</strong>。</p>
<p><strong>定义</strong></p>
<p>在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 需要注意：新开的浏览器窗口会生成新的Session，但子窗口除外。子窗口会共用父窗口的Session。例如，在链接上右击，在弹出的快捷菜单中选择”在新窗口中打开”时，子窗口便可以访问父窗口的Session。需要注意：只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session</p>
<p>Session和cookie的区别与联系</p>
<p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。两者存储的都是用户登录信息，操作行为等等的数据。</p>
<p>cookie是把用户的数据写在用户本地浏览器上, 其他网站也可以扫描使用你的cookie，容易泄露自己网站用户的隐私，而且一般浏览器对单个网站站点有cookie数量与大小的限制。<br>Session是把用户的数据写在用户的独占session上，存储在服务器上，一般只将session的id存储在cookie中。但将数据存储在服务器对服务器的成本会高。<br>session是由服务器创建的，开发人员可以在服务器上通过request对象的getsession方法得到session<br>一般情况，登录信息等重要信息存储在session中，其他信息存储在cookie中<br>session的实现原理</p>
<p>服务器会为每一个访问服务器的用户创建一个session对象，并且把sessionid保存在本地cookie上，只要用户再次访问服务器时，带着session的id，服务器就会匹配用户在服务器上的session，根据session中的数据，还原用户上次的浏览状态或提供其他人性化服务。</p>
<p>cookie与session的对比</p>
<p>session<br>保存在服务器端用户信息<br>session中保存的是Object类型<br>随会话的结束而将其存储的数据销毁<br>保存重要的信息</p>
<p>session过期,服务器关闭</p>
<p>cookie<br>在客户端保存用户信息<br>cookie保存的是 String类型<br>cookie可以长期保存在客户端<br>保存不重要的用户信息</p>
<blockquote>
<p>若不设置过期时间: 表示这个cookie的生命周期为浏览器回话期间,</p>
<p>关闭访问服务器的浏览器窗口，cookie就消失了。一般称为回话cookie，保存在内存中 若设置了过期时间,则cookie会存在硬盘上,直到超过有效时间</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务</title>
    <url>/2020/02/22/Spring%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>事务管理对于企业应用来说是至关重要的，当出现异常情况时，它也可以保证数据的一致性。</p>
<h2 id="Spring事务管理的两种方式"><a href="#Spring事务管理的两种方式" class="headerlink" title="Spring事务管理的两种方式"></a>Spring事务管理的两种方式</h2><p><strong>spring支持编程式事务管理和声明式事务管理两种方式。</strong></p>
<a id="more"></a>

<ul>
<li><strong>编程式事务</strong>使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</li>
<li><strong>声明式事务</strong>是建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。</li>
</ul>
<p>显然声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，它的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。</p>
<p>声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。</p>
<h2 id="spring事务特性"><a href="#spring事务特性" class="headerlink" title="spring事务特性"></a>spring事务特性</h2><p>spring所有的事务管理策略类都继承自<code>org.springframework.transaction.PlatformTransactionManager</code>接口。</p>
<p>其中<code>TransactionDefinition</code>接口定义以下特性：</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li>TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</li>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
<li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h3 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h3><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p>
<p>默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。</p>
<h3 id="spring事务回滚规则"><a href="#spring事务回滚规则" class="headerlink" title="spring事务回滚规则"></a>spring事务回滚规则</h3><p>默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。可以明确的配置在抛出哪些异常时回滚事务，包括checked异常。也可以明确定义那些异常抛出时不回滚事务。还可以编程性的通过setRollbackOnly()方法来指示一个事务必须回滚，在调用完setRollbackOnly()后你所能执行的唯一操作就是回滚。</p>
<h2 id="以MyBatis为例，基于注解的声明式事务配置"><a href="#以MyBatis为例，基于注解的声明式事务配置" class="headerlink" title="以MyBatis为例，基于注解的声明式事务配置"></a>以MyBatis为例，基于注解的声明式事务配置</h2><p>1、添加tx名字空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:tx="http://www.springframework.org/schema/tx"</span><br></pre></td></tr></table></figure>

<p>2、开启事务的注解支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启事务控制的注解支持 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、MyBatis自动参与到spring事务管理中，无需额外配置，只要org.mybatis.spring.SqlSessionFactoryBean引用的数据源与DataSourceTransactionManager引用的数据源一致即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span> </span><br><span class="line">		<span class="comment">&lt;!-- 注入数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 绑定Mybatis的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事务有以下几个常用属性：</p>
<p>a.read-only:设置该事务中是否允许修改数据。（对于只执行查询功能的事务，设置为TRUE可以提高事务的执行速度）  </p>
<p>b.propagation：事务的传播机制。一般设置为required。可以保证在事务中的代码只在当前事务中运行，防止创建多个事务。</p>
<p>c.isolation:事务隔离级别。不是必须的。默认值是default。</p>
<p>d.timeout:允许事务运行的最长时间，以秒为单位。</p>
<p>e.rollback-for:触发回滚的异常。</p>
<p>f.no-rollback-for:不会触发回滚的异常。</p>
<p>***实际开发中，对于只执行查询功能的事务，要设置read-only为TRUE，其他属性一般使用默认值即可。</p>
<p><strong>4、使用@Transactional注解</strong></p>
<p>@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该注解来覆盖类级别的定义。</p>
<p>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring <strong>建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效</strong>。另外， @Transactional 注解应该只被应用到 public 方法上<strong>，这是由 Spring AOP 的本质决定</strong>(因为AOP基于动态代理)**的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.spring.dao;  </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">import</span> java.util.Iterator;  </span><br><span class="line">  <span class="keyword">import</span> java.util.List;  </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">import</span> javax.sql.DataSource;  </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;  </span><br><span class="line">  <span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;  </span><br><span class="line">  <span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;  </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">import</span> demo.spring.entity.Person;  </span><br><span class="line">  <span class="meta">@Transactional</span><span class="comment">//将此类进行事务管理  </span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDaoImpl</span> <span class="keyword">implements</span> <span class="title">PersonDao</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> JdbcTemplate jt;  </span><br><span class="line">        </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span></span>&#123;  </span><br><span class="line">          jt = <span class="keyword">new</span> JdbcTemplate(dataSource);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="meta">@Override</span>  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">          jt.update(<span class="string">"insert into person values('"</span>+id+<span class="string">"','"</span>+name+<span class="string">"','"</span>+age+<span class="string">"')"</span>);  </span><br><span class="line">    </span><br><span class="line">      &#125;  </span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Transactional</span>(propagation= Propagation.REQUIRED)<span class="comment">//定义要事务管理的方法，指定传播行为  </span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchInsert</span><span class="params">(List persons)</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">for</span>(Iterator it = persons.iterator(); it.hasNext(); )&#123;  </span><br><span class="line">              Person p = (Person) it.next();  </span><br><span class="line">              insert(p.getId(),p.getName(),p.getAge());  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="以MyBatis为例，基于-xml文件的声明式事务配置"><a href="#以MyBatis为例，基于-xml文件的声明式事务配置" class="headerlink" title="以MyBatis为例，基于.xml文件的声明式事务配置"></a>以MyBatis为例，基于.xml文件的声明式事务配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"advice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span> <span class="attr">rollback-for</span>=<span class="string">"java.lang.Exception"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"insert"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"testService"</span> <span class="attr">expression</span>=<span class="string">"execution (* com.nnngu.service.MyBatisService.*(..))"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"advice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"testService"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>————————————————<br>参考文章:<br>原文链接：<a href="https://blog.csdn.net/csdn_huzeliang/article/details/78995795" target="_blank" rel="noopener">https://blog.csdn.net/csdn_huzeliang/article/details/78995795</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2020/02/22/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h3 id="SSM脚手架"><a href="#SSM脚手架" class="headerlink" title="SSM脚手架"></a>SSM脚手架</h3><p>spring + springMVC + Mybatis + log4j + MybatisGenerator </p>
<p>实现了</p>
<ul>
<li><p>简单配置</p>
</li>
<li><p>日志打印</p>
</li>
<li><p>逆向文件</p>
</li>
<li><p>上传文件的配置</p>
</li>
<li><p>加入了Json 和 Restful 的配置 (在spring-mvc.xml 和 web.xml)</p>
<a id="more"></a>


</li>
</ul>
<h4 id="SSM整合步骤"><a href="#SSM整合步骤" class="headerlink" title="SSM整合步骤"></a>SSM整合步骤</h4><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/22/3MQkKe.png" alt="3MQkKe.png"></p>
<h4 id="mybatis-config-xml-简化类命名空间-配置数据源交给spring管理"><a href="#mybatis-config-xml-简化类命名空间-配置数据源交给spring管理" class="headerlink" title="mybatis-config.xml:  简化类命名空间,配置数据源交给spring管理"></a>mybatis-config.xml:  简化类命名空间,配置数据源交给spring管理</h4><h4 id="spring-dao-xml"><a href="#spring-dao-xml" class="headerlink" title="spring-dao.xml :"></a>spring-dao.xml :</h4><ol>
<li><p>关联数据库文件,引入database.properties</p>
</li>
<li><p>配置数据源连接池信息: dataSource</p>
</li>
<li><p>配置sqlSessionFactory对象 :</p>
<ul>
<li>注入数据源 :dataSource</li>
<li>绑定mybatis配置文件 : configLocation</li>
<li>绑定Sql映射文件的地址: mapperLocation</li>
</ul>
</li>
<li><p>配置dao接口扫描包,动态实现dao接口注入到spring容器中</p>
<ul>
<li>将 sqlSessionFactory 注入 bean 中 :  sqlSessionFactoryBeanName</li>
<li>扫描 dao 包<h4 id="spring-service-xml"><a href="#spring-service-xml" class="headerlink" title="spring-service.xml"></a>spring-service.xml</h4></li>
</ul>
</li>
<li><p>开启注解配置  </p>
</li>
<li><p>扫描 service 包</p>
</li>
<li><p>声明事务配置 : DataSourceTransactionManager </p>
</li>
<li><p>aop 事务支持</p>
</li>
</ol>
<h4 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring-mvc.xml:"></a>spring-mvc.xml:</h4><ol>
<li>注解驱动: 可加入对Json传输的支持</li>
<li>静态资源过滤</li>
<li>扫描 Controller 包<ul>
<li>扫描@Controller注解</li>
</ul>
</li>
<li>配置视图解析器</li>
<li>配置文件解析器(可选)</li>
</ol>
<h4 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h4><ol>
<li>配置监听器启动Spring容器</li>
<li>将url控制交给 springMVC 的 DispatcherServlet(核心分发器)</li>
<li>乱码过滤</li>
<li>session过期时间</li>
<li>添加对 put 和 delete方式的支持</li>
</ol>
<p>附整合项目的连接:</p>
<p><a href="https://github.com/zenghui6/SSM-" target="_blank" rel="noopener">https://github.com/zenghui6/SSM-</a></p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>springmvc</tag>
        <tag>mybatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC工作原理</title>
    <url>/2020/02/17/SpringMVC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="四个组件各司其职"><a href="#四个组件各司其职" class="headerlink" title="四个组件各司其职"></a>四个组件各司其职</h3><ul>
<li>DispatcherServlet: 作为前端控制器,整个流程控制的中心,控制其他组件执行,统一调度,降低组件之间的耦合性,提高每个组件的扩展性</li>
<li>HandlerMapping: 根据配置文件找到具体的处理者(Hander),并生成处理器对象,和处理器拦截器</li>
<li>HandlerAdapter: 将处理者对象(Hander)根据规则(例如get post请求方式) 执行不同的Controller</li>
<li>ViewResolver: 将MAV 解析后 返回具体的 view</li>
</ul>
<a id="more"></a>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/17/3PRjc6.jpg" alt="3PRjc6.jpg"></p>
<h3 id="SpringMVC工作原理"><a href="#SpringMVC工作原理" class="headerlink" title="SpringMVC工作原理"></a>SpringMVC工作原理</h3><ol>
<li>用户发送请求到<strong>前端控制器</strong> DispatcherServlet</li>
<li>DispatcherServlet收到请求调用 HandlerMapping 处理者映射器</li>
<li>处理者映射器找到具体的处理器(handler) (可以根据xml配置,注解进行查找) , 生成处理器对象和处理器拦截器(如有则生成) 一并返回给DispatcherServlet</li>
<li>DispatcherServlet调用 HanderAdapter 处理者适配器</li>
<li>HanderAdapter 经过适配调用具体的处理器 (Controller)</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HanderAdapter 将Controller返回的ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet 将 ModelAndView 传给 ViewResolver视图解析器</li>
<li>ViewResolver解析后返回具体的view</li>
<li>DispatcherServlet 根据 view进行渲染 (将模型数据填充到视图中)</li>
<li>DispatcherServlet 响应用户</li>
</ol>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射和动态代理</title>
    <url>/2020/02/13/Java%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>Spring IOC 使用的是 Java的反射</p>
<p>Spring AOP 使用的是 动态代理</p>
<a id="more"></a>

<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射?"></a>什么是反射?</h3><p>主要是指程序可以访问,检测和修改它本身状态或行为的一种能力</p>
<p>在Java运行时环境中,对于<strong>任意一个类</strong>,能否知道这个类有哪些属性和方法?对于<strong>任意一个对象</strong> 能否调用它的任意一个方法?</p>
<p>Java的反射机制主要提供了以下功能:</p>
<ol>
<li>在运行时判断任意一个对象所属的类.</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行是调用任意一个对象的方法</li>
</ol>
<h3 id="什么是-Java-的序列化-什么情况下需要序列化"><a href="#什么是-Java-的序列化-什么情况下需要序列化" class="headerlink" title="什么是 Java 的序列化? 什么情况下需要序列化?"></a>什么是 Java 的序列化? 什么情况下需要序列化?</h3><p>Java 序列化是为了保存各种对象在内存中的状态,并且可以把保存的对象再读出来.</p>
<p>以下情况需要使用Java序列化:</p>
<ul>
<li>想把内存中的对象状态保存到一个文件中或数据库中的时候;</li>
<li>想用Socket在网络上传输对象的时候;</li>
<li>想通用远程方法调用传输对象的时候;</li>
</ul>
<p>注意事项:</p>
<ul>
<li>某个类可以被序列化,则其子类也可以被序列化</li>
<li>声明为 static 和 transient 的成员变量,不能被序列化. static 成员变量是描述类级别的属性,transient 表示临时数据</li>
<li>反序列化读取序列化对象的顺序要保持一致</li>
</ul>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><code>Proxy</code> : 代理人——代替别人工作的人 “本人”寻找“代理人”工作，但是代理人毕竟是代理人，能代替本人所做的事有限，当代理人无法帮忙时再寻找本人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IRegisterService iRegisterService = <span class="keyword">new</span> RegisterServiceImpl();</span><br><span class="line">        IRegisterService proxy = <span class="keyword">new</span> RegisterServiceProxy(iRegisterService);</span><br><span class="line">        proxy.register(<span class="string">"RyanLee"</span>, <span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRegisterService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String name, String pwd)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterServiceImpl</span> <span class="keyword">implements</span> <span class="title">IRegisterService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String name, String pwd)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"【向数据库中插入数据】name：%s，pwd：%s"</span>, name, pwd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterServiceProxy</span> <span class="keyword">implements</span> <span class="title">IRegisterService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//本人,代理人持有本人的引用,当代理人无法完成要求时,再生成本人</span></span><br><span class="line">    IRegisterService iRegisterService; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterServiceProxy</span><span class="params">(IRegisterService iRegisterService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iRegisterService = iRegisterService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String name, String pwd)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[Proxy]一些前置处理"</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"[Proxy]打印注册信息：姓名：%s,密码：%s"</span>, name, pwd));</span><br><span class="line">        iRegisterService.register(name, pwd);</span><br><span class="line">        System.out.println(<span class="string">"[Proxy]一些后置处理"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Proxy</span>]一些前置处理</span><br><span class="line">[<span class="meta">Proxy</span>]打印注册信息：姓名：RyanLee,密码：<span class="number">123</span></span><br><span class="line">【向数据库中插入数据】name：RyanLee，pwd：<span class="number">123</span></span><br><span class="line">[<span class="meta">Proxy</span>]一些后置处理</span><br></pre></td></tr></table></figure>

<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理: 无需声明代理类.是使用反射和字节码的技术,在<strong>运行期创建指定接口或类的子类</strong>(即动态代理类) 以及其实例对象的技术.</p>
<p>使用动态代理可以<strong>无侵入的对代码进行增强</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/13/1qcFqe.jpg" alt="1qcFqe.jpg"></p>
<p>​            图: java源文件编译生成字节码</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/13/1qcAVH.jpg" alt="1qcAVH.jpg"></p>
<p>​                       图: 动态代理生成字节码对象</p>
<h3 id="动态代理的实现方式"><a href="#动态代理的实现方式" class="headerlink" title="动态代理的实现方式"></a>动态代理的实现方式</h3><h4 id="JDK-原生动态代理"><a href="#JDK-原生动态代理" class="headerlink" title="JDK 原生动态代理"></a>JDK 原生动态代理</h4><p>动态代理类和被代理类必须继承同一个接口.动态代理只能对接口中声明的方法进行代理.</p>
<h5 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h5><p>java.lang.reflect.Proxy 是所有动态代理的父类, 它通过静态方法newProxyInstance() 来创建动态代理的class对象 和 实例</p>
<h5 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h5><p>每个动态代理实例都有一个关联的InvocationHandler (程序调用处理者).通过代理实例调用方法,方法调用请求会被转发给 InvocationHandler 的 invoke (调用) 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK动态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJdkDynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建实例</span></span><br><span class="line">        IRegisterService iRegisterService = <span class="keyword">new</span> RegisterServiceImpl();</span><br><span class="line">        <span class="comment">//生成应用调用处理器</span></span><br><span class="line">        RegisterHandler registerHandler = <span class="keyword">new</span> RegisterHandler();</span><br><span class="line">        <span class="comment">//生成代理对象</span></span><br><span class="line">        IRegisterService proxy = (IRegisterService) registerHandler.getProxy(iRegisterService);</span><br><span class="line">        proxy.register(<span class="string">"R1"</span>,<span class="string">"1111"</span>);</span><br><span class="line">        proxy.login(<span class="string">"R2"</span>,<span class="string">"1111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接口</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IRegisterService</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String name,String pwd)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(String name,String pwd)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterServiceImpl</span> <span class="keyword">implements</span> <span class="title">IRegisterService</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String name, String pwd)</span> </span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"【向数据库中插入数据】name：%s，pwd：%s"</span>, name, pwd));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String name, String pwd)</span> </span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"【登录数据】name：%s，pwd：%s"</span>, name, pwd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">        Object object;</span><br><span class="line">        <span class="comment">//获取代理对象的class对象和实例</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.object = object;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            doBefore();</span><br><span class="line">            Object result = method.invoke(object,args);</span><br><span class="line">            doAfter();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"[Proxy]:一些前置处理"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"[Proxy]:一些后置处理"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">Proxy</span>]:<span class="link">一些前置处理</span></span><br><span class="line">【向数据库中插入数据】name：R1，pwd：1111</span><br><span class="line">[<span class="symbol">Proxy</span>]:<span class="link">一些后置处理</span></span><br><span class="line">[<span class="symbol">Proxy</span>]:<span class="link">一些前置处理</span></span><br><span class="line">【登录数据】name：R2，pwd：1111</span><br><span class="line">[<span class="symbol">Proxy</span>]:<span class="link">一些后置处理</span></span><br></pre></td></tr></table></figure>





<h4 id="使用-CGLIB"><a href="#使用-CGLIB" class="headerlink" title="使用 CGLIB"></a>使用 CGLIB</h4><p>JDK代理必须要提供接口,而CGLIB则不需要,可以直接代理类</p>
<blockquote>
<p>待补充…..</p>
</blockquote>
<h3 id="动态代理是什么-应用场景"><a href="#动态代理是什么-应用场景" class="headerlink" title="动态代理是什么? 应用场景?"></a>动态代理是什么? 应用场景?</h3><p>动态代理: 在运行是,创建目标类,可以调用和扩展目标类的方法</p>
<p>Java 中实现动态代理的方式: JDK中的动态代理 和 Java类库 CGLIb</p>
<p>应用场景:</p>
<ul>
<li><p>统计每个 api 的请求耗时,(扩展目标类:调用前加个时间,调用后加个时间)</p>
</li>
<li><p>统一的日志输出</p>
</li>
<li><p>校验被调用的 api 是否已经登录和权限鉴定</p>
</li>
<li><p>Spring 的 AOP 功能模块就是采用动态代理的机制来实现切面编程</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程中的锁</title>
    <url>/2020/02/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类:"></a>锁的分类:</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>很悲观,认为每次去拿数据的时候都认为会修改,所以每次都在拿数据的时候上锁</p>
<a id="more"></a>

<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>synchronized与 Lock interface</p>
<p>Java中实现加锁的方式: 一种是使用synchronized 关键字,另一种是使用Lock 接口的实现类</p>
<p>synchronized 关键字就像是<strong><em>自动档</em></strong> ,可以满足一切驾驶的需求.</p>
<p>但如果你想做更高级的操作,就需要<strong><em>手动挡</em></strong> ,也就是 Lock 接口的实现类.</p>
<h4 id="synchronized-锁升级过程"><a href="#synchronized-锁升级过程" class="headerlink" title="synchronized 锁升级过程:"></a>synchronized 锁升级过程:</h4><p><strong><em>偏向锁  -&gt;  轻量级锁 -&gt; 重量级锁</em></strong></p>
<p> 使用 synchronized 关键字锁住某个代码块时,一开始<strong><em>锁对象</em></strong></p>
<p>(就是下面代码中的object)并不是重量级锁,而是偏向锁.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>偏向锁</em></strong> 的纸面意思就是”<strong><em>偏向于第一个获取它的线程</em></strong>“的锁.线程执行完同步代码块后,并不会主动释放偏向锁.</p>
<p>当第二次达到同步代码块时,线程会判断此时持有锁的线程是否就是自己 (持有锁的线程ID在对象头里存储),如果是则正常往下执行.<strong><em>由于之前没有释放,这里就不需要重新加锁</em></strong>,如果从头到尾都是一个线程在使用锁,很明显偏向锁几乎没有额外开销,性能极高.</p>
<p>一但有第二个线程加入<strong><em>锁竞争</em></strong>, 偏向锁转换为<strong><em>轻量级锁(自旋锁)</em></strong>.只有当某个线程获取锁时,发现锁已经被占用,需要等待其释放,则说明发生了锁竞争.</p>
<p>在轻量级锁的状态下继续锁竞争,没有抢到锁的线程进行<strong><em>自旋</em></strong>  操作,即在一个循环中不断判断是否可以获取锁.</p>
<p>获取锁的操作,就是用过<strong>CAS</strong>操作修改对象头里的锁标志位.先<strong><em>比较</em></strong> 当前锁标志位是否为<strong><em>释放</em></strong>状态,如果是,则将其设置为<strong><em>锁定</em></strong> 状态, CAS 是在JVM层面实现的,是原子性操作.当前线程就算持有了锁,然后线程将<strong>当前锁的持有者信息</strong>改为自己.</p>
<p>假如我们获取到锁的线程操作时间很长,比如会进行复杂的计算,数据量很大的网络传输等;那么其他等待锁的线程就会进入长时间的自旋操作,这个过程是非常耗资源的,这时候<strong>只有一个线程在有效的工作</strong>,其他线程什么都干不了,在白白的消耗 CPU,这种现象叫做<strong><em>忙等</em></strong></p>
<p>显然<strong><em>忙等</em></strong>是有限度的(可通过虚拟机参数更改).如果锁竞争情况严重,达到某个最大自旋次数的线程,会将轻量级锁<strong>升级为重量级锁</strong>(依然是通过CAS修改锁标志位,但不修改持有锁的线程 ID)</p>
<p>当后续线程尝试获取锁时,发现被占用的锁是重量级锁,则直接将自己<strong>挂起</strong>(而不是上面说的忙等,即不会自旋),等待释放锁的线程去唤醒.</p>
<p>JVM中,synchronized 锁只能按照偏向锁,轻量锁,重量锁逐渐升级,不允许降级.</p>
<h4 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h4><p>可重入锁的字面意思是”可以重新进入的锁”,即***运行同一个线程多次获取同一把锁”.</p>
<p>如果不是可重入锁,在递归函数中就会造成死锁,所有Java中的锁基本都是可重入锁</p>
<h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><p>如果多个线程申请一把<strong>公平锁</strong>,那么获得锁的线程释放锁的时候,先申请的先得到,很公平.</p>
<p>如果是<strong>非公平锁</strong>,后申请的线程可能先获得锁,是随机获取还是其他方式,都是根据实现算法而定的.</p>
<p>对于 ReentrantLock类而言,通过构造函数可以<strong>指定该锁是否是公平锁,默认是非公平锁</strong></p>
<p>而对于synchronized 锁而言,它只能是一种非公平锁,没有任何方式使其变成公平锁.</p>
<h4 id="共享锁和互斥锁"><a href="#共享锁和互斥锁" class="headerlink" title="共享锁和互斥锁"></a>共享锁和互斥锁</h4><p>在Java中, ReentrantLock,synchronized 锁都是互斥锁</p>
<p>也有具体的共享锁实例类,如: Semaphore</p>
<h4 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h4><p>字面意思是”可以<strong>响应中断</strong>的锁”</p>
<p>Java的<strong>中断不能直接终止线程</strong>,只是设置了状态为响应中断的状态,需要被中断的线程自己决定怎么处理.</p>
<p>如果线程A持有锁,线程 B 等待获取该锁,由于A持有锁的时间过长,线程B不想继续等,我们可能让线程B中断自己或者在别的线程里面中断 B,这就是可中段锁.</p>
<p>在Java中, synchronize 锁 是<strong>不可中断锁</strong>,而 Lock 的实现类都是<strong>可中断锁</strong></p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote>
<p>很乐观,认为每次去拿数据的时候都不会修改,所以不会上锁</p>
<p>但是如果想更新数据,则会在<strong>更新之前检查在读取至更新这段时间别人有没有修改过这个数据</strong> 如果修改过,这重新读取,再次尝试更新,循环,直到更新成功(当然也允许更新失败的线程放弃更新操作)(CAW)Compare-and-Swap 比较并替换</p>
</blockquote>
<h4 id="乐观锁的基础-—CAS"><a href="#乐观锁的基础-—CAS" class="headerlink" title="乐观锁的基础 —CAS"></a>乐观锁的基础 —CAS</h4><p>CSA? Compare-and-Swap 即比较并替换</p>
<ul>
<li>比较: 读取到一个值 A,在将其更新为 B 之前,检查原值是否为 A</li>
<li>替换: 如果是,更新A为 B.结束. 如果不是,则不会更新.</li>
</ul>
<p>CAS 利用 CPU指令,从硬件上保证了原子性,以达到类似锁的效果.</p>
<p>从乐观锁的整个流程中可以看出,<strong>并没有加锁和解锁</strong>的操作,因此乐观锁策略也被称为<strong>无锁编程</strong>.换句话说,乐观锁其实不是”锁”,它仅仅是一个循环重试的CAS算法而已</p>
<p>在Java中也是通过navtive方法实现的CAS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1,<span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1,<span class="keyword">long</span> var2, <span class="keyword">int</span> var4 ,<span class="keyword">int</span> var5)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1,<span class="keyword">long</span> var2, Long var4,Long var5)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>Java中使用的各种锁基本上是<strong>悲观锁</strong>,Java中的乐观锁在java.util.concurrent.atomic下面的原子类.</p>
<h3 id="怎么预防死锁"><a href="#怎么预防死锁" class="headerlink" title="怎么预防死锁?"></a>怎么预防死锁?</h3><p>为什么会造成死锁:</p>
<ol>
<li>互斥 :任一时刻一个资源只能给一个进程使用</li>
<li>占用等待</li>
<li>非剥夺</li>
<li>循环等待</li>
</ol>
<p>如何防止死锁:</p>
<ul>
<li>尽量使用 tryLick()的方法,设置超时时间,超时可以退出防止死锁</li>
<li>尽量使用Java.util.concurrent 并发类代替自己手写锁</li>
<li>尽量降低锁的使用粒度,尽量不要几个功能用同一把锁</li>
<li>尽量减少同步的代码块</li>
</ul>
<h3 id="synchronized-和-Lock-有什么区别"><a href="#synchronized-和-Lock-有什么区别" class="headerlink" title="synchronized 和 Lock 有什么区别?"></a>synchronized 和 Lock 有什么区别?</h3><ul>
<li>synchronized 可以给类,方法,代码块加锁,而Lock 只能给代码块加锁</li>
<li>synchronized 不需要手动获取锁和释放锁;使用简单,发生异常会自动释放锁,不会造成死锁;而Lock 需要自己加锁和释放锁,如果使用不当,没有 unLock() 区释放就会造成死锁</li>
<li>通过Lock可以知道有没有成功获取锁, 而synchronized却没法办到</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/02/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行?"></a>并发与并行?</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/11/1IjNc9.jpg" alt="1IjNc9.jpg"></p>
<a id="more"></a>

<p>并发 = 两个队列和一台咖啡机</p>
<p>并行 = 两个队列和两台咖啡机</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程?"></a>进程与线程?</h3><p><strong>进程 (Process)</strong> 是计算机中的程序关于某数据集合上的一次运行活动,是系统进行资源分配和调度的基本单位,是操作系统的基础.</p>
<p><strong><em>线程(thread)</em></strong> 是操作系统能进行运算调度的最小单位. 它被包含在进程中,是进程中的实际运作单位</p>
<h3 id="创建线程有哪几种方式"><a href="#创建线程有哪几种方式" class="headerlink" title="创建线程有哪几种方式?"></a>创建线程有哪几种方式?</h3><ol>
<li>继承Tread类 重写 run 方法;</li>
<li>实现Runnable 接口;</li>
<li>实现Callable 接口;</li>
</ol>
<h3 id="说一下-Runnable-和-Callable-有什么区别"><a href="#说一下-Runnable-和-Callable-有什么区别" class="headerlink" title="说一下 Runnable 和 Callable 有什么区别?"></a>说一下 Runnable 和 Callable 有什么区别?</h3><p>Runnable 没有返回值, Callable有返回值, Callable 可以看做 Runnable 的补充.</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态?"></a>线程的状态?</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/11/1IxrSe.jpg" alt="1IxrSe.jpg"></p>
<ol>
<li>新建(new) : 新创建一个线程对象</li>
<li>可运行状态(Runnaable):  就绪状态,线程对象创建后,被其他线程抢占处理机. 该状态的线程位于可运行线程池中,等待被线程调度选中,获取CPU的使用权.</li>
<li>运行(Running): 可运行状态的线程获得了CPU时间片, 执行程序代码.</li>
<li>阻塞(Blocked): 阻塞状态是指线程因为某种原因放弃了CPU的使用权, 暂时停止运行,直到线程进入可运行状态,才有机会再次获得CPU使用权,转入运行状态.阻塞的情况分为三种<ul>
<li>等待阻塞:  运行的线程执行o.wait()方法,JVM会把该线程放入<strong>等待队列</strong>(waitting queue)中.</li>
<li>同步阻塞: 运行的线程在获取对象的同步锁时,若该同步锁被别的线程占用,则JVM会把该线程放入锁池(lock pool)中.</li>
<li>其他阻塞: 运行的线程执行Thread.sleep() 或<strong>其他线程t2调用 join()</strong> 方法,或者发出I/O请求时,JVM 会把该线程置于阻塞状态.当sleep()状态超时,join() 等待线程终止或超时,或者I/O处理完毕时,线程重新转入可运行状态</li>
</ul>
</li>
<li>死亡(Dead): 线程run(),main() 方法执行结束,或者因异常退出了run()方法,则该线程结束生命周期.死亡的线程不可再生.</li>
</ol>
<blockquote>
<p>等待队列:(本是Object里的方法,但影响了线程)</p>
<p>调用 obje 的 wait(),notify() 方法前,必须获得obj锁 , 也就是必须写在Synchronized(obj)代码块内.</p>
</blockquote>
<h3 id="sleep-好-wait-有什么区别"><a href="#sleep-好-wait-有什么区别" class="headerlink" title="sleep() 好 wait() 有什么区别?"></a>sleep() 好 wait() 有什么区别?</h3><ul>
<li>类的不同: sleep() 来自 Thread, wait() 来自 Object.</li>
<li>释放锁: sleep() 不释放锁; wait()释放锁.</li>
<li>用法不同: sleep() 时间到会自动恢复; wait()可以使用 notify()/notifyAll() 直接唤醒.</li>
</ul>
<h3 id="线程notify-和-notifyAll-有什么区别"><a href="#线程notify-和-notifyAll-有什么区别" class="headerlink" title="线程notify() 和 notifyAll() 有什么区别?"></a>线程notify() 和 notifyAll() 有什么区别?</h3><ul>
<li>notifyAll() 会唤醒所有线程, notify()之后唤醒一个线程(<strong><em>具体唤醒哪个线程由虚拟机控制</em></strong>).</li>
<li>notifyAll() 调用后,会将全部线程由<strong><em>等待池移到锁池</em></strong>,然后参与锁的竞争,竞争成功则继续执行,如果不成功则留在锁池等待锁被释放后再次参与竞争.</li>
</ul>
<h3 id="线程的run-和-start-有什么区别"><a href="#线程的run-和-start-有什么区别" class="headerlink" title="线程的run() 和 start() 有什么区别?"></a>线程的run() 和 start() 有什么区别?</h3><p>start() 方法用于启动线程,run() 方法用于执行线程的运行时代码. run() 可以重复调用,start()只能一次.</p>
<h3 id="线程池都有哪些状态"><a href="#线程池都有哪些状态" class="headerlink" title="线程池都有哪些状态?"></a>线程池都有哪些状态?</h3><p>ThreadPoolExecutor() : 是最原始的线程池创建,一共有7种</p>
<ul>
<li>Running: 这是最正常的状态,接受新的任务,处理等待队列中的任务.</li>
<li>Shutdown: 不接受新的任务提交,但是会继续处理等待队列中的任务.</li>
<li>Stop: 不接受新的任务提交,不再处理等待队列中的任务,中断正在执行任务的线程.</li>
<li>Tidying(整理): 所有的任务都撤销了,workCount为0,线程池状态在转换为Tidying状态时,会执行钩子函数 terminated().</li>
<li>Terminated: terminated() 方法结束后,线程池的状态就会变成这个.</li>
</ul>
<h3 id="线程池中submit-和-execute-方法有什么区别"><a href="#线程池中submit-和-execute-方法有什么区别" class="headerlink" title="线程池中submit() 和 execute()方法有什么区别?"></a>线程池中submit() 和 execute()方法有什么区别?</h3><ul>
<li>execute():  只能执行 Runnable 类型的任务</li>
<li>submit() : 可以执行Runnable 和 Callable类型的任务.</li>
</ul>
<h3 id="在Java程序中怎么保证多线程的运行安全"><a href="#在Java程序中怎么保证多线程的运行安全" class="headerlink" title="在Java程序中怎么保证多线程的运行安全?"></a>在Java程序中怎么保证多线程的运行安全?</h3><ul>
<li>方法一: 使用安全类, 比如 Java.util.concurrent下的类</li>
<li>方法二: 使用自动锁synchronized.</li>
<li>方法三: 使用手动锁Lock.</li>
</ul>
<p>就总结到这把,下一次写Java中的各种锁吧,然后再结合锁来处理多线程的问题!</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 容器</title>
    <url>/2020/02/10/Java-%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="Java容器都有哪些"><a href="#Java容器都有哪些" class="headerlink" title="Java容器都有哪些?"></a>Java容器都有哪些?</h2><p>Java容器分为Collection 和 Map 两大类,其下又有很多子类</p>
<a id="more"></a>

<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection:"></a>Collection:</h3><ul>
<li>List</li>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector                 //线程安全</li>
<li>Stack                  //线程安全</li>
<li>Set</li>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map:"></a>Map:</h3><ul>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
<li>Hashtable                     //线程安全</li>
<li>ConcurrentHashMap    多线程下使用的并发HashMap,在java.util.concurrent下</li>
</ul>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/10/14X4Fe.jpg" alt="14X4Fe.jpg"></p>
<h2 id="Collection-和-Collections有什么区别"><a href="#Collection-和-Collections有什么区别" class="headerlink" title="Collection 和 Collections有什么区别?"></a>Collection 和 Collections有什么区别?</h2><ul>
<li>Collection是一个集合接口,它提供了对集合对象进行基本操作的通用接口方法,所有集合都是他的子类,比如List,Set等.</li>
<li>Collections是一个包装类,包含了很多静态方法,不能被实例化,就像一个工具类,比如提供的排序方法: Collections.sort(list).</li>
</ul>
<h2 id="说一下-HashMap的实现原理"><a href="#说一下-HashMap的实现原理" class="headerlink" title="说一下 HashMap的实现原理"></a>说一下 HashMap的实现原理</h2><p>HashMap基于Hash算法实现:</p>
<p>我们通过put(key,value)存储,get(key)来获取.当传入key是,HashMap会根据key.hashCode()计算出 hash 值.</p>
<p>根据hash值将value 保存在 bucket(桶)里,当计算出的hash值相同时,hash冲突,HashMap的做法是用链表和红黑树存储相同的hash值的value.当hash冲突的个数比较少时,使用链表,当数量增长到一定长度链表就转化为红黑树.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/10/14LnSI.png" alt="14LnSI.png"></p>
<h2 id="说一下HashSet的实现原理"><a href="#说一下HashSet的实现原理" class="headerlink" title="说一下HashSet的实现原理?"></a>说一下HashSet的实现原理?</h2><p>HashSet是基于HashMap实现的,HashSet底层使用HashMap来保存所有元素,因此HashSet的实现比较简单,相关HashSet的操作,基本上都是直接调用底层的HashMap的相关方法来完成,HashSet不允许出现重复</p>
<h2 id="ArrayList-和-LinkedList-的区别是什么"><a href="#ArrayList-和-LinkedList-的区别是什么" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么?"></a>ArrayList 和 LinkedList 的区别是什么?</h2><ul>
<li>数据机构的实现:  ArrayList是<strong><em>动态数组</em></strong>的数据结构实现,而LinkedList是双向链表的数据结构实现.</li>
<li>随机访问效率: ArrayList 比 LinkedList在随机访问的时候效率高,因为LinkedList是线性的数据存储方式,所以需要移动指针从前往后依次查找</li>
<li>增加和删除效率: 在非收尾的增加和删除操作,LinkedList要比ArrayList效率要高,因为ArrayList是动态数组实现,增删操作会影响数组内后面数据的下标.</li>
</ul>
<h2 id="如何实现数组与List之间的转换"><a href="#如何实现数组与List之间的转换" class="headerlink" title="如何实现数组与List之间的转换"></a>如何实现数组与List之间的转换</h2><ul>
<li>数组转List:  使用Arrays.asList(array)进行转换</li>
<li>List转数组: 使用List自带的toArray()方法</li>
</ul>
<blockquote>
<p>迭代器Iterator  Collection接口继承了Iterator接口</p>
<p>Iterator的特点是更加安全,因为他可以确保,在当前遍历的集合元素被更改的时候,就会抛出<code>ConcurrentModificationException</code>异常</p>
</blockquote>
<h2 id="在Queue中-poll-和-remove-有什么区别"><a href="#在Queue中-poll-和-remove-有什么区别" class="headerlink" title="在Queue中 poll()和 remove()有什么区别?"></a>在Queue中 poll()和 remove()有什么区别?</h2><ul>
<li>相同点: 都是返回第一个元素,并在队列中删除返回的对象</li>
<li>不同点: 如果没有元素poll() 会返回null , 而 remove() 会直接抛出 NoSuchElementException异常.</li>
</ul>
<h2 id="如何确保一个集合不能被修改"><a href="#如何确保一个集合不能被修改" class="headerlink" title="如何确保一个集合不能被修改?"></a>如何确保一个集合不能被修改?</h2><p>可以使用Collections.unmodifiableCollection(Collection c) 方法来创建一个只读的集合,这样改变集合的任何操作都会抛出Java.lang.UnsupportedOperationException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"x"</span>);</span><br><span class="line">Collection&lt;String&gt; collection=Collections.unmodifiableCollection(list);</span><br><span class="line">collection.add(<span class="string">"y"</span>);</span><br><span class="line">System.out.println(collection.size());</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>map</tag>
        <tag>set</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>map的分类和常见情况</title>
    <url>/2020/02/09/map%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p>java 数据结构中映射定义了一个接口java.util.Map</p>
<p>它有四个实现类:</p>
<ol>
<li>HashMap</li>
<li>Hashtable</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
</ol>
<a id="more"></a>

<p>Map主要用于存储键值对,根据键得到值,因此不允许键重复,但允许值重复</p>
<h3 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h3><p>Hashmap是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值,具有很快的访问速度.</p>
<p>遍历时,<strong><em>取得数据的顺序是完全随机</em></strong>的.</p>
<p>HashMap最多只允许一条记录的键为Null;</p>
<p>HashMap<strong><em>不支持线程的同步</em></strong>,即任一时刻可以有多个线程同时写HashMap,可能导致数据不一致.</p>
<p>如果需要同步,可以用Collections的synchronizedMap方法使HashMap具有同步能力,或者使用ConcurrentHashMap.</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable与HashMap类似,它继承自Dictionary类,</p>
<p>不同的是: 它不允许记录的键或者值为空,它<strong><em>支持线程的同步</em></strong>,即任一时刻只有一个线程能写Hashtable,因此也导致了Hashtable在写入时会比较慢.</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap是HashMap的一个子类,保存了记录的插入顺序,在用Iterator遍历LinkedHashMap时,先得到的记录肯定是先插入的,也可以在构造时用带参数,按照应用次数排序.</p>
<p>在遍历时会比HashMap慢,不过有种情况例外,当HashMap容量很大,实际数据较少时,遍历起来可能会比LinkedHashMap慢,因为LinkedHashMap的遍历速度只与实际数据有关,和容量无关,而HashMap的遍历速度和它的容量有关.</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>*<em>线程不安全 *</em></p>
<p>TreeMap实现SortMap接口,基于红黑树的,能够把它保存的记录根据键排序,默认是按键值的升序排序,也可以指定排序的比较器,当用Iterator遍历TreeMap时,得到的记录是排过序的.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p>
<p>HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。</p>
<p>HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</p>
<p>Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。</p>
<p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。</p>
<p>在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>map</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql锁</title>
    <url>/2020/02/08/Mysql%E9%94%81/</url>
    <content><![CDATA[<h2 id="宏观"><a href="#宏观" class="headerlink" title="宏观"></a>宏观</h2><h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁　"></a>数据库锁　</h3><pre><code>粒度小，方便用于集群环境</code></pre><h3 id="代码锁"><a href="#代码锁" class="headerlink" title="代码锁"></a>代码锁</h3><pre><code>粒度大，需要封装</code></pre><a id="more"></a>

<h2 id="微观"><a href="#微观" class="headerlink" title="微观"></a>微观</h2><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h4 id="行锁＆表锁"><a href="#行锁＆表锁" class="headerlink" title="行锁＆表锁"></a>行锁＆表锁</h4><p><strong><em>只有明确指定主键，才会执行行锁，否则执行表锁</em></strong></p>
<blockquote>
<p>无锁</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主键不存在</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">-1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>行锁</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主键明确</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">'kkk'</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>表锁</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主键不明确</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'kkk'</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt;&gt; <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<h2 id="锁算法"><a href="#锁算法" class="headerlink" title="锁算法"></a>锁算法</h2><h3 id="行锁算法"><a href="#行锁算法" class="headerlink" title="行锁算法"></a>行锁算法</h3><p> Record Lock:单个行记录上的锁</p>
<ul>
<li>键值在条件范围内</li>
<li>记录存在</li>
</ul>
<p>Gap Lock:间隙锁</p>
<ul>
<li>锁定一个范围,但不包含记录本身</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#id只有1-50</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">50</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>


<p>Next-Key Lock:(行&amp;间隙)</p>
<ul>
<li>锁定一个范围,并且锁定记录本身<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#id只有1-50</span></span><br><span class="line">  <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">id</span>&gt;<span class="number">49</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<h3 id="表锁算法"><a href="#表锁算法" class="headerlink" title="表锁算法"></a>表锁算法</h3>意向锁(升级机制)</li>
<li>当一个事务带着表锁去访问一个加了行锁的资源,那么,此时这个行锁就会升级成意向锁,将表锁住.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#事务A -升级表锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;  //此时是行锁</span><br><span class="line"><span class="comment">#事务B -锁表</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'kkk'</span> <span class="keyword">for</span> <span class="keyword">update</span>;//升级表锁</span><br></pre></td></tr></table></figure>
<p>自增锁</p>
<ul>
<li>事务插入自增类型的列时,获取自增锁<blockquote>
<p>  如果一个事务正在往表中插入自增记录,其他事务都必须等待,对于有自增长值的列的并发插入性能较差,事务必须等待</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java查漏补缺</title>
    <url>/2020/02/08/Java%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<h2 id="String-StringBuffer-StringBuilder的区别"><a href="#String-StringBuffer-StringBuilder的区别" class="headerlink" title="String StringBuffer StringBuilder的区别"></a>String StringBuffer StringBuilder的区别</h2><ol>
<li>操作数量较少的字符串用String，不可修改的字符串；</li>
<li>在多线程且操作大量字符串用StringBuffer，线程安全，可修改。</li>
<li>在单线程且操作大量字符串用StringBuilder,速度快，但线程不安全，可修改； <a id="more"></a>

</li>
</ol>
<h2 id="变量存放在哪"><a href="#变量存放在哪" class="headerlink" title="变量存放在哪?"></a>变量存放在哪?</h2><p>基本数据类型是放在栈中还是放在堆中，这取决于基本类型在何处声明，下面对数据类型在内存中的存储问题来解释一下：</p>
<p>   一：在<strong>方法中声明的变量</strong>，即该变量是局部变量，每当<strong>程序调用方法时</strong>，系统都会为该方法建立一个<strong>方法栈</strong>，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因</p>
<pre><code>在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。

   （1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中

   （2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）
       是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</code></pre><p>   二：在类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。</p>
<pre><code>同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量

（1）当声明的是基本类型的变量其变量名及其值放在堆内存中的

（2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。
      引用变量名和对应的对象仍然存储在相应的堆中</code></pre><h2 id="请你讲讲数组-Array-和列表-ArrayList-的区别？"><a href="#请你讲讲数组-Array-和列表-ArrayList-的区别？" class="headerlink" title="请你讲讲数组(Array)和列表(ArrayList)的区别？"></a>请你讲讲数组(Array)和列表(ArrayList)的区别？</h2><ol>
<li>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型(对基本类型实现自动装箱)。</li>
<li>Array大小是固定的，ArrayList的大小是动态变化的。</li>
<li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</li>
</ol>
<h2 id="请你解释什么是值传递和引用传递？"><a href="#请你解释什么是值传递和引用传递？" class="headerlink" title="请你解释什么是值传递和引用传递？"></a>请你解释什么是值传递和引用传递？</h2><ul>
<li><p>值传递是针对基本变量而言,传递的是该变量的一个副本,改变副本不影响原变量</p>
</li>
<li><p>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象</p>
</li>
<li><p>一般认为,java内的传递都是值传递.</p>
<p>在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。<br>只是在传递过程中：</p>
<p><strong>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</strong></p>
<p><strong>如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</strong></p>
</li>
</ul>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类也就是没有名字的内部类<br>正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写</p>
<p>但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到,我们直接将抽象类Person中的方法在大括号中实现了<br>这样便可以省略一个类的书写<br>匿名内部类还可以直接作用于接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  <span class="comment">//多线程匿名内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java8-新特性"><a href="#java8-新特性" class="headerlink" title="java8 新特性"></a>java8 新特性</h2><ol>
<li>lambda表达式 : 允许函数作为另一个方法的参数</li>
<li>方法引用: 可以直接引用已有Java类或实例的方法或构造器</li>
<li>默认方法: 在一个接口里有了一个默认的实现方法</li>
<li>新工具: 新的编译工具和类依赖分析工具</li>
<li>Stream API: 把真正的函数式编程引入java</li>
<li>Date Time API :加强对日期时间的处理</li>
<li>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>avaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用</li>
</ol>
<h2 id="HashCode-Object的默认HashCode-是什么-为什么重写equals-还要重写hashCode"><a href="#HashCode-Object的默认HashCode-是什么-为什么重写equals-还要重写hashCode" class="headerlink" title="HashCode Object的默认HashCode()是什么?为什么重写equals() 还要重写hashCode()?"></a>HashCode Object的默认HashCode()是什么?为什么重写equals() 还要重写hashCode()?</h2><ul>
<li>Object 的HashCode()方法是<strong>本地方法</strong>,即使用C/C++实现的,该方法直接返回对象的<strong>内存地址</strong></li>
<li>首先我们要知道HashMap()比较key的时候的过程:</li>
</ul>
<ol>
<li>先求出key的HashCode值,判断是否相等</li>
<li>若相等再判断equals()是否相等,若相等则认为是相等的</li>
</ol>
<blockquote>
<p>现在有两个Student对象：</p>
</blockquote>
<pre><code>Student s1=new Student(&quot;小明&quot;,18);

Student s2=new Student(&quot;小明&quot;,18);</code></pre><p>此时,如果不重写equals方法,s1.equals(s2)为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object 源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//可知equals的本质就是 == </span></span><br><span class="line"><span class="comment">//String 和包装类都重写了 equals方法</span></span><br></pre></td></tr></table></figure>



<p>假如只重写equals而不重写hashcode，那么Student类的hashcode方法就是Object默认的hashcode方法，由于默认的hashcode方法是<strong>本地方法</strong>是根据<strong>对象的内存地址</strong>经哈希算法得来的，显然此时<strong>s1!=s2</strong>,故两者的hashcode不一定相等。</p>
<blockquote>
<p>HashCode判断key相等,实际上是调用了HashSet()方法.</p>
</blockquote>
<p>重载hashCode()是为了对同一个key，能得到相同的Hash Code，这样HashMap就可以定位到我们指定的key上</p>
<h2 id="Java中的Math-round-1-5-等于多少"><a href="#Java中的Math-round-1-5-等于多少" class="headerlink" title="Java中的Math.round(-1.5)等于多少"></a>Java中的Math.round(-1.5)等于多少</h2><blockquote>
<p>Math.round(-1.5)的返回值是-1</p>
<p>四舍五入的原理是在参数上加0.5然后向下取整</p>
</blockquote>
<h2 id="String-str-“i”-与-String-str-new-String-“i”-一样吗"><a href="#String-str-“i”-与-String-str-new-String-“i”-一样吗" class="headerlink" title="String str = “i” 与 String str = new String(“i”)一样吗?"></a>String str = “i” 与 String str = new String(“i”)一样吗?</h2><p><a href="https://imgchr.com/i/14y5TS" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/10/14y5TS.md.png" alt="14y5TS.md.png"></a></p>
<p><strong>堆</strong>：存放对象的实例以及对象的属性和方法</p>
<p><strong>栈</strong>：储存基本数据类型的值、执行的方法、方法中声明的变量、数组、对象的引用(reference类型)</p>
<p><strong>方法区</strong>：存储已被虚拟机加载的类元数据信息(元空间)</p>
<p><strong>运行时常量池</strong>：常量(final)、字符串</p>
<p>String str=”i”: Java虚拟机会将其分配到<strong><em>常量池</em></strong>中;</p>
<p>String str = new String(“i”) : 则会分到<strong><em>堆内存</em></strong>中,即使内容一样还是会创建新对象</p>
<p>在常量池中没有重复的元素,Java虚拟机会先在常量池中检索是否已经存在,如果有那么就直接赋值地址,如果没就创建一个,然后再赋给变量;</p>
<h2 id="抽象类与接口和普通类的区别"><a href="#抽象类与接口和普通类的区别" class="headerlink" title="抽象类与接口和普通类的区别"></a>抽象类与接口和普通类的区别</h2><ol>
<li>抽象类要被子类继承,接口要被类实现</li>
<li>接口只能做方法声明,抽象类中可以作方法声明,也可以做方法实现</li>
<li>接口里定义的变量只能是公共的静态的变量,抽象类中的变量是普通变量</li>
<li>抽象类可以有具体的方法和属性,接口只能有抽象方法和不可变常量.</li>
<li>构造函数: 抽象类可以有构造函数;接口不能有</li>
<li>抽象类不能直接实例化,普通类可以直接实例化</li>
</ol>
<h2 id="Java中的IO流分几种"><a href="#Java中的IO流分几种" class="headerlink" title="Java中的IO流分几种?"></a>Java中的IO流分几种?</h2><p>字节流和字符流.</p>
<p>字节流和字符流的区别是: 字节流按8位传输以字节为单位输入输出数据,字符流按16位字符为单位输入输出数据.</p>
<h2 id="BIO-NIO-AIO有什么区别"><a href="#BIO-NIO-AIO有什么区别" class="headerlink" title="BIO,NIO,AIO有什么区别?"></a>BIO,NIO,AIO有什么区别?</h2><ul>
<li>BIO: Block IO同步阻塞式IO,就是平常使用的IO,它的特点是模式简单使用方便,并发处理能力低.</li>
<li>NIO: Non IO同步非阻塞IO, 是传统的IO的升级,客户端和服务器端通过Channel(通道) 通讯,实现了多路复用.</li>
<li>AIO: Asynchronous IO 是NIO的升级,也叫NIO2,实现了异步非阻塞IO,异步IO的操作基于事件和回调机制.</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>se</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql数据库隔离级别</title>
    <url>/2020/02/08/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h1><p>事务只是一个改变,是<strong>一些操作的集合</strong>;<br>用专业的术语讲,它就是一个程序的执行单元;<br><strong>事务本身其实并不包括这4个特性</strong>,我们需要通过某些手段,尽可能的让这个执行单元满足这四个特性,那么我们就称他为一个事务,或者说是一个正确的事务</p>
<a id="more"></a>


<h1 id="2-四特性"><a href="#2-四特性" class="headerlink" title="2,四特性"></a>2,四特性</h1><ol>
<li>原子性:满足原子操作单元,对数据的操作,要么全部执行,要么全部失败</li>
<li>一致性: 从一个正确的状态迁移到另一个正确的状态   <strong><em>一致性是目的</em></strong> AID是为了保证C</li>
<li>隔离性:事务之间是相互独立的,中间状态是不可见的</li>
<li>持久性:数据的修改是永久的</li>
</ol>
<h1 id="3-隔离级别"><a href="#3-隔离级别" class="headerlink" title="3,隔离级别"></a>3,隔离级别</h1><h2 id="3-1-并发情况下事务引发的问题"><a href="#3-1-并发情况下事务引发的问题" class="headerlink" title="3.1 并发情况下事务引发的问题"></a>3.1 并发情况下事务引发的问题</h2><pre><code>一般情况下,多个单元操作并发执行,会出现这么几个问题</code></pre><ol>
<li><p>脏读:A事务还未提交,B事务就读到了A事务的结果.(破坏了隔离性)</p>
</li>
<li><p>不可重复读:A事务在本次事务中,对自己未操作过的数据,进行了多次读取,结果出现了不一致或记录不存在的情况.(破坏了一致性,update和delete)<strong>指在事务1内，读取了一个数据，事务1还没有结束时，事务2也访问了这个数据，修改了这个数据，并提交。紧接着，事务1又读这个数据。由于事务2的修改，那么事务1两次读到的的数据可能是不一样的，因此称为是不可重复读。</strong></p>
</li>
<li><p>幻读:A事务在本次事务中,对自己未操作过的数据,进行了多次读取,第一次读取时,记录不存在,第二次读取时,记录出现了.(破坏了一致性,insert)</p>
</li>
</ol>
<h2 id="3-2解决-制定标准"><a href="#3-2解决-制定标准" class="headerlink" title="3.2解决(制定标准)"></a>3.2解决(制定标准)</h2><p>为了权衡<strong>隔离</strong>与<strong>并发</strong>的矛盾,ISO定义了四个事务的隔离机制,每个级别的隔离程度不同,允许出现的副作用也不同</p>
<ol>
<li>未提交读(read-uncommitted):最低级别,只能保证持久性</li>
<li>提交读(read-committed):语句级别的</li>
<li>可重复读(repeatable-read):事务级别</li>
<li>串行化(serializable):最高级别,事务与事务完成串行化执行,毫无并发可言,性能极低</li>
</ol>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读</td>
<td>会</td>
<td>会</td>
<td>会</td>
</tr>
<tr>
<td>提交读</td>
<td>-</td>
<td>会</td>
<td>会</td>
</tr>
<tr>
<td>可重复读</td>
<td>-</td>
<td>-</td>
<td>会</td>
</tr>
<tr>
<td>串行化</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>注意:这四个级别只是一个标准,各个数据库厂商,并不是完全按照这个标准来做的</p>
<p><code>&lt;https://blog.csdn.net/Vincent2014Linux/article/details/89669762&gt;</code></p>
<p>这篇博客总结的非常好</p>
<h2 id="3-3-实现-InnoDB"><a href="#3-3-实现-InnoDB" class="headerlink" title="3.3 实现(InnoDB)"></a>3.3 实现(InnoDB)</h2><h3 id="1-锁机制-阻止事务对数据的操作-各个隔离级别主要体现在读取数据时加的锁和释放时机"><a href="#1-锁机制-阻止事务对数据的操作-各个隔离级别主要体现在读取数据时加的锁和释放时机" class="headerlink" title="1. 锁机制:阻止事务对数据的操作,各个隔离级别主要体现在读取数据时加的锁和释放时机"></a>1. 锁机制:阻止事务对数据的操作,各个隔离级别主要体现在读取数据时加的锁和释放时机</h3><ul>
<li>RU:事务读取的时候不加锁</li>
<li>RC: 事务读取的时候加行级共享锁(读到才加锁),一旦读完,立刻释放(并不是事务结束).</li>
<li>RR: 事务读取时加行级共享锁,直到事务结束才会释放</li>
<li>SE: 事务读取是加表级共享锁,直到事务结束才会释放<h3 id="2-MVCC机制-生成一个数据快照-并用这个快照来提供一定级别的一致性的读取-也成为了多版本数据控制"><a href="#2-MVCC机制-生成一个数据快照-并用这个快照来提供一定级别的一致性的读取-也成为了多版本数据控制" class="headerlink" title="2. MVCC机制:生成一个数据快照,并用这个快照来提供一定级别的一致性的读取,也成为了多版本数据控制."></a>2. MVCC机制:生成一个数据快照,并用这个快照来提供一定级别的一致性的读取,也成为了多版本数据控制.</h3></li>
<li>实际就是<strong>CAS版本控制</strong>和<strong>读写分离</strong>的思想</li>
<li>主要作用于RC和RR级别</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
